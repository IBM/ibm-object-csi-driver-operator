
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>constants: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibm-object-csi-driver-operator/controllers/constants/constants.go (0.0%)</option>
				
				<option value="file1">github.com/IBM/ibm-object-csi-driver-operator/controllers/ibmobjectcsi_controller.go (76.9%)</option>
				
				<option value="file2">github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/common/common.go (0.0%)</option>
				
				<option value="file3">github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils/common.go (0.0%)</option>
				
				<option value="file4">github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils/ibmobjectcsi.go (0.0%)</option>
				
				<option value="file5">github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils/k8s-resource-ops.go (0.0%)</option>
				
				<option value="file6">github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils/static_resource_generator.go (0.0%)</option>
				
				<option value="file7">github.com/IBM/ibm-object-csi-driver-operator/controllers/logParser.go (96.2%)</option>
				
				<option value="file8">github.com/IBM/ibm-object-csi-driver-operator/controllers/recoverstalevolume_controller.go (94.9%)</option>
				
				<option value="file9">github.com/IBM/ibm-object-csi-driver-operator/controllers/syncer/common.go (0.0%)</option>
				
				<option value="file10">github.com/IBM/ibm-object-csi-driver-operator/controllers/syncer/csi_controller.go (0.0%)</option>
				
				<option value="file11">github.com/IBM/ibm-object-csi-driver-operator/controllers/syncer/csi_node.go (0.0%)</option>
				
				<option value="file12">github.com/IBM/ibm-object-csi-driver-operator/controllers/test_variables.go (100.0%)</option>
				
				<option value="file13">github.com/IBM/ibm-object-csi-driver-operator/controllers/util/boolptr.go (0.0%)</option>
				
				<option value="file14">github.com/IBM/ibm-object-csi-driver-operator/controllers/util/common/common.go (0.0%)</option>
				
				<option value="file15">github.com/IBM/ibm-object-csi-driver-operator/controllers/util/datastructures.go (0.0%)</option>
				
				<option value="file16">github.com/IBM/ibm-object-csi-driver-operator/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package constants ...
package constants

import (
        "fmt"
        "time"
)

const (
        APIGroup = "objectdriver.csi.ibm.com"

        APIVersion           = "v1"
        CSIOperatorName      = "ibm-object-csi-driver-operator"
        CSIOperatorNamespace = "ibm-object-csi-operator"
        CSIDriverName        = "ibm-object-csi-driver"
        DriverName           = "cos.s3.csi.ibm.io"
        DeploymentName       = "ibm-object-csi-operator-controller-manager"

        RbacAuthorizationAPIGroup = "rbac.authorization.k8s.io"
        SecurityOpenshiftAPIGroup = "security.openshift.io"
        StorageAPIGroup           = "storage.k8s.io"

        CSINodesResource                   = "csinodes"
        SecretsResource                    = "secrets"
        SecurityContextConstraintsResource = "securitycontextconstraints"
        StorageClassesResource             = "storageclasses"
        EventsResource                     = "events"
        NodesResource                      = "nodes"
        PersistentVolumesResource          = "persistentvolumes"
        PersistentVolumeClaimsResource     = "persistentvolumeclaims"
        ConfigMapResource                  = "configmaps"

        VerbGet    = "get"
        VerbList   = "list"
        VerbWatch  = "watch"
        VerbCreate = "create"
        VerbUpdate = "update"
        VerbPatch  = "patch"
        VerbDelete = "delete"

        CSINodeDriverRegistrar = "csi-node-driver-registrar"
        CSIProvisioner         = "csi-provisioner"
        LivenessProbe          = "livenessprobe"

        ControllerSocketVolumeMountPath                       = "/var/lib/csi/sockets/pluginproxy/"
        NodeSocketVolumeMountPath                             = "/csi"
        ControllerLivenessProbeContainerSocketVolumeMountPath = "/csi"
        ControllerSocketPath                                  = "/var/lib/csi/sockets/pluginproxy/csi.sock"
        NodeSocketPath                                        = "/csi/csi.sock"
        NodeRegistrarSocketPath                               = "/var/lib/kubelet/plugins/cos.s3.csi.ibm.io/csi.sock"
        COSCSIMounterSocketPath                               = "/var/lib/coscsi-sock/coscsi.sock"
        CSIEndpoint                                           = "unix:///var/lib/csi/sockets/pluginproxy/csi.sock"
        CSINodeEndpoint                                       = "unix:///csi/csi.sock"
        RegistrationVolumeMountPath                           = "/registration"

        NodeContainerName       = "ibm-object-csi-node"
        ControllerContainerName = "ibm-object-csi-controller"

        RegistrationVolumeName = "registration-dir"
        PluginVolumeName       = "plugin-dir"
        SocketVolumeName       = "socket-dir"

        HealthPortName                = "healthz"
        HealthPortNumber              = 9808
        CosCsiMounterHealthPortName   = "socket-health"
        CosCsiMounterHealthPortNumber = 9080

        CSIController                         = "controller"
        CSINode                               = "node"
        CSIControllerServiceAccount           = "controller-sa"
        CSINodeServiceAccount                 = "node-sa"
        ExternalProvisionerClusterRole        = "external-provisioner-clusterrole"
        ExternalProvisionerClusterRoleBinding = "external-provisioner-clusterrolebinding"
        CSIControllerSCCClusterRole           = "controller-scc-clusterrole"
        CSIControllerSCCClusterRoleBinding    = "controller-scc-clusterrolebinding"
        CSINodeSCCClusterRole                 = "node-scc-clusterrole"
        CSINodeSCCClusterRoleBinding          = "node-scc-clusterrolebinding"
        CSINodePriorityClassName              = "system-node-critical"
        CSIControllerPriorityClassName        = "system-cluster-critical"

        ParamsConfigMap          = "managed-addon-ibm-object-csi-driver"
        ParamsConfigMapNamespace = "kube-system"
        ObjectCSIDriver          = "ibm-object-csi"

        RetainPolicyTag = "retain"

        StorageClassPrefix = "ibm-object-storage"

        RcloneRetainStorageClass = StorageClassPrefix + "-rclone-retain"
        RcloneStorageClass       = StorageClassPrefix + "-rclone"
        S3fsRetainStorageClass   = StorageClassPrefix + "-s3fs-retain"
        S3fsStorageClass         = StorageClassPrefix + "-s3fs"

        S3ProviderIBM    = "ibm-cos"
        S3ProviderAWS    = "aws"
        S3ProviderWasabi = "wasabi"
        IaasIBMClassic   = "ibm-classic"
        IaasIBMVPC       = "ibm-vpc"

        IBMEP    = "https://s3.%s.%s.cloud-object-storage.appdomain.cloud"
        AWSEP    = "https://s3.%s.amazonaws.com"
        WasabiEP = "https://s3.%s.wasabisys.com"

        DefaultLogTailLines    = 300
        DefaultNamespace       = "default"
        ReconcilationTime      = 5 * time.Minute
        TransportEndpointError = "transport endpoint is not connected"

        InfraProviderPlatformIBM = "IBMCloud"
        InfraProviderType        = "VPC"

        MaxVolumesPerNodeEnv = "MAX_VOLUMES_PER_NODE"
        //ConfigMap keys
        MaxVolumesPerNodeCMKey       = "maxVolumesPerNode"
        NodeServerCPURequestCMKey    = "nodeServerCPURequest"
        NodeServerMemoryRequestCMKey = "nodeServerMemoryRequest"
        NodeServerCPULimitCMKey      = "nodeServerCPULimit"
        NodeServerMemoryLimitCMKey   = "nodeServerMemoryLimit"
)

type FinalizerOps int

const (
        AddFinalizer FinalizerOps = iota + 1
        RemoveFinalizer
)

var CommonCSIResourceLabels = map[string]string{
        "app.kubernetes.io/part-of":    CSIDriverName,
        "app.kubernetes.io/managed-by": CSIOperatorName,
}

var CommonCSIResourceLabelForCaching = map[string]string{
        "app.kubernetes.io/part-of": CSIDriverName,
}

// GetResourceName returns the name of a resource for a CSI driver
func GetResourceName(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", ObjectCSIDriver, name)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package controllers ...
package controllers

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "time"

        objectdriverv1alpha1 "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        crutils "github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils"
        clustersyncer "github.com/IBM/ibm-object-csi-driver-operator/controllers/syncer"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util/common"
        "github.com/IBM/ibm-object-csi-driver-operator/version"
        "github.com/go-logr/logr"
        "github.com/presslabs/controller-util/pkg/syncer"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        storagev1 "k8s.io/api/storage/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

type reconciler func(instance *crutils.IBMObjectCSI) error

var csiLog = logf.Log.WithName("ibmobjectcsi_controller")

// IBMObjectCSIReconciler reconciles a IBMObjectCSI object
type IBMObjectCSIReconciler struct {
        client.Client
        Scheme           *runtime.Scheme
        Recorder         record.EventRecorder
        ControllerHelper *common.ControllerHelper
}

//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=ibmobjectcsis,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=ibmobjectcsis/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=ibmobjectcsis/finalizers,verbs=update
//+kubebuilder:rbac:groups="",resources=pods,verbs=get;delete;list;watch
//+kubebuilder:rbac:groups="",resources=configmaps,verbs=get;create;delete;list;watch;update
//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=persistentvolumeclaims,verbs=get;list;watch;update;patch
//+kubebuilder:rbac:groups="",resources=persistentvolumeclaims/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=monitoring.coreos.com,resources=servicemonitors,verbs=get;create
//+kubebuilder:rbac:groups="",resources=persistentvolumeclaims/finalizers,verbs=update
//+kubebuilder:rbac:groups="",resources=persistentvolumes,verbs=get;delete;list;watch;update;create;patch
//+kubebuilder:rbac:groups="",resources=events,verbs=*
//+kubebuilder:rbac:groups="",resources=nodes,verbs=get;list;watch
//+kubebuilder:rbac:groups=apps,resources=deployments;daemonsets;statefulsets,verbs=get;list;watch;update;create;delete
//+kubebuilder:rbac:groups="",resources=serviceaccounts,verbs=create;delete;get;watch;list
//+kubebuilder:rbac:groups=rbac.authorization.k8s.io,resources=clusterroles;clusterrolebindings,verbs=create;delete;get;watch;list;update;patch
//+kubebuilder:rbac:groups=storage.k8s.io,resources=storageclasses,verbs=get;list;watch
//+kubebuilder:rbac:groups=apps,resourceNames=ibm-object-csi-operator,resources=deployments/finalizers,verbs=update
//+kubebuilder:rbac:groups=storage.k8s.io,resources=csidrivers,verbs=create;delete;get;watch;list
//+kubebuilder:rbac:groups=storage.k8s.io,resources=csinodes,verbs=get;list;watch
//+kubebuilder:rbac:groups=security.openshift.io,resourceNames=anyuid;privileged,resources=securitycontextconstraints,verbs=use
//+kubebuilder:rbac:groups=apiextensions.k8s.io,resources=customresourcedefinitions,verbs=create;list;watch;delete
//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=*,verbs=*
//+kubebuilder:rbac:groups=storage.k8s.io,resources=storageclasses,verbs=create;get;list;watch;delete;update;patch
//+kubebuilder:rbac:groups=config.openshift.io,resources=infrastructures,verbs=get;list

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the IBMObjectCSI object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.14.1/pkg/reconcile
func (r *IBMObjectCSIReconciler) Reconcile(ctx context.Context, req ctrl.Request) (reconcile.Result, error) <span class="cov8" title="1">{
        reqLogger := csiLog.WithValues("Request.Namespace", req.Namespace, "Request.Name", req.Name)
        r.ControllerHelper.Log = csiLog

        // Check if the reconcile was triggered by the ConfigMap events
        if req.Namespace == constants.ParamsConfigMapNamespace &amp;&amp; req.Name == constants.ParamsConfigMap </span><span class="cov0" title="0">{
                reqLogger.Info("Reconcile triggered by create/update event on ConfigMap")
                // Handle the update of IBMObjectCSI
                return r.handleConfigMapReconcile(ctx, req)
        }</span>
        <span class="cov8" title="1">reqLogger.Info("Reconciling IBMObjectCSI")

        // Fetch the CSIDriver instance
        instance := crutils.New(&amp;objectdriverv1alpha1.IBMObjectCSI{})
        err := r.Get(ctx, req.NamespacedName, instance.Unwrap())
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Return and don't requeue
                        return reconcile.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov8" title="1">return reconcile.Result{}, err</span>
        }
        //setting default values for a Kubernetes Custom Resource using the Scheme's Default() method, based on the Go type definition of the Custom Resource.
        //This ensures that the CR has all the required fields with default values before further processing or reconciliation by the operator.
        <span class="cov8" title="1">r.Scheme.Default(instance.Unwrap())
        if err := r.ControllerHelper.AddFinalizerIfNotPresent(
                instance, instance.Unwrap()); err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">s3Provider := instance.Spec.S3Provider
        if s3Provider == "" </span><span class="cov8" title="1">{
                s3Provider = constants.S3ProviderIBM
        }</span>
        <span class="cov8" title="1">r.ControllerHelper.S3Provider = s3Provider
        r.ControllerHelper.S3ProviderRegion = instance.Spec.S3ProviderRegion

        // If the deletion timestamp is set, perform cleanup operations and remove a finalizer before returning from the reconciliation process.
        if !instance.GetDeletionTimestamp().IsZero() </span><span class="cov8" title="1">{
                if err := r.deleteClusterRoleBindings(instance); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.deleteClusterRoles(instance); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.deleteStorageClasses(instance); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.deleteCSIDriver(instance); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.ControllerHelper.RemoveFinalizer(
                        instance, instance.Unwrap()); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">return reconcile.Result{}, nil</span>
        }
        <span class="cov8" title="1">originalStatus := *instance.Status.DeepCopy()

        // Fetch the ConfigMap instance
        configMap := &amp;corev1.ConfigMap{}
        err = r.Get(ctx, types.NamespacedName{Name: constants.ParamsConfigMap, Namespace: constants.ParamsConfigMapNamespace}, configMap)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        reqLogger.Info("ConfigMap not found. Retry after 5 seconds...", "name", constants.ParamsConfigMap, "namespace", constants.ParamsConfigMapNamespace)
                        return reconcile.Result{RequeueAfter: 5 * time.Second}, nil
                }</span>
                <span class="cov0" title="0">reqLogger.Error(err, "Failed to get ConfigMap", constants.ParamsConfigMap)
                // Error reading the object - requeue the request.
                return reconcile.Result{}, err</span>
        }

        <span class="cov8" title="1">if crUpdateRequired := checkIfupdateCRFromConfigMapRequired(instance.Unwrap(), configMap); crUpdateRequired </span><span class="cov8" title="1">{
                // Update the instance in the Kubernetes API server
                reqLogger.Info("IBMObjectCSI spec is not in sync with configmap data. Updating IBMObjectCSI CR...")
                err = r.Update(ctx, instance.Unwrap())
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error(err, "Failed to update IBMObjectCSI instance as per configMap data")
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">reqLogger.Info("IBMObjectCSI CR is updated as per configmap data")
                return reconcile.Result{}, nil</span>
        }

        // create the resources if not exist
        <span class="cov8" title="1">for _, rec := range []reconciler{
                r.reconcileCSIDriver,
                r.reconcileServiceAccount,
                r.reconcileClusterRole,
                r.reconcileClusterRoleBinding,
        } </span><span class="cov8" title="1">{
                if err = rec(instance); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }

        // sync the resources which change over time
        <span class="cov8" title="1">csiControllerSyncer := clustersyncer.NewCSIControllerSyncer(r.Client, instance)
        if err := syncer.Sync(ctx, csiControllerSyncer, r.Recorder); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">csiNodeSyncer := clustersyncer.NewCSINodeSyncer(r.Client, instance)
        if err := syncer.Sync(ctx, csiNodeSyncer, r.Recorder); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">if err = r.reconcileStorageClasses(instance); err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">if err := r.updateStatus(instance, originalStatus); err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        // Resources created successfully - don't requeue
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// handleConfigMapReconcile handles reconciliation triggered by the ConfigMap event
func (r *IBMObjectCSIReconciler) handleConfigMapReconcile(ctx context.Context, req ctrl.Request) (reconcile.Result, error) <span class="cov0" title="0">{
        reqLogger := csiLog.WithValues("Request.Namespace", req.Namespace, "Request.Name", req.Name)
        reqLogger.Info("Handling Reconcile IBMObjectCSI for ConfigMap event")

        // Fetch the ConfigMap instance
        configMap := &amp;corev1.ConfigMap{}
        err := r.Get(ctx, req.NamespacedName, configMap)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        reqLogger.Info("ConfigMap not found. Ignoring configmap event...", "name", req.Name, "namespace", req.Namespace)
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">reqLogger.Error(err, "Failed to get ConfigMap", req.Name)
                // Error reading the object - requeue the request.
                return reconcile.Result{}, err</span>
        }

        // Fetch the IBMObjectCSI instance
        <span class="cov0" title="0">instance := &amp;objectdriverv1alpha1.IBMObjectCSI{}

        err = r.Get(ctx, types.NamespacedName{
                Namespace: constants.CSIOperatorNamespace,
                Name:      constants.ObjectCSIDriver},
                instance)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error(err, "Failed to get IBMObjectCSI instance")
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">reqLogger.Info("IBMObjectCSI CR fetched successfully")

        if crUpdateRequired := checkIfupdateCRFromConfigMapRequired(instance, configMap); crUpdateRequired </span><span class="cov0" title="0">{
                // Update the instance in the Kubernetes API server
                reqLogger.Info("IBMObjectCSI spec is not in sync with configmap data. Updating IBMObjectCSI CR...")
                err = r.Update(ctx, instance)
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error(err, "Failed to update IBMObjectCSI instance as per configMap data")
                        return reconcile.Result{}, err
                }</span>
                <span class="cov0" title="0">reqLogger.Info("IBMObjectCSI CR is updated as per configmap data")
                return reconcile.Result{}, nil</span>
        }
        <span class="cov0" title="0">reqLogger.Info("IBMObjectCSI spec is already in sync with configmap data. IBMObjectCSI CR update is not needed")
        return reconcile.Result{}, nil</span>
}

func (r *IBMObjectCSIReconciler) updateStatus(instance *crutils.IBMObjectCSI, originalStatus objectdriverv1alpha1.IBMObjectCSIStatus) error <span class="cov8" title="1">{
        logger := csiLog.WithName("updateStatus")

        controllerDeployment, err := r.getControllerDeployment(instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nodeDaemonSet, err := r.getNodeDaemonSet(instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">instance.Status.ControllerReady = r.isControllerReady(controllerDeployment)
        instance.Status.NodeReady = r.isNodeReady(nodeDaemonSet)
        var phase objectdriverv1alpha1.DriverPhase
        if instance.Status.ControllerReady &amp;&amp; instance.Status.NodeReady </span><span class="cov8" title="1">{
                phase = objectdriverv1alpha1.DriverPhaseRunning
        }</span> else<span class="cov8" title="1"> {
                if !instance.Status.ControllerReady </span><span class="cov8" title="1">{
                        controllerPod, err := r.getControllerPod(controllerDeployment)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "failed to get controller pod")
                                return err
                        }</span>

                        <span class="cov8" title="1">if !r.areAllPodImagesSynced(controllerDeployment, controllerPod) </span><span class="cov8" title="1">{
                                if err := r.restartControllerPodfromDeployment(logger, controllerDeployment, controllerPod); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err, "failed to restart controller pod from deployment")
                                }</span>
                        }
                }
                <span class="cov8" title="1">phase = objectdriverv1alpha1.DriverPhaseCreating</span>
        }
        <span class="cov8" title="1">instance.Status.Phase = phase
        instance.Status.Version = version.DriverVersion

        if !reflect.DeepEqual(originalStatus, instance.Status) </span><span class="cov8" title="1">{
                logger.Info("updating IBMObjectCSI status", "name", instance.Name, "from", originalStatus, "to", instance.Status)
                sErr := r.Status().Update(context.TODO(), instance.Unwrap())
                if sErr != nil </span><span class="cov8" title="1">{
                        return sErr
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *IBMObjectCSIReconciler) restartControllerPodfromDeployment(logger logr.Logger,
        controllerDeployment *appsv1.Deployment, controllerPod *corev1.Pod) error <span class="cov8" title="1">{
        logger.Info("controller requires restart",
                "ReadyReplicas", controllerDeployment.Status.ReadyReplicas,
                "Replicas", controllerDeployment.Status.Replicas)
        logger.Info("restarting csi controller")
        return r.Delete(context.TODO(), controllerPod)
}</span>

func (r *IBMObjectCSIReconciler) getControllerPod(controllerDeployment *appsv1.Deployment) (*corev1.Pod, error) <span class="cov8" title="1">{
        var listOptions = &amp;client.ListOptions{Namespace: controllerDeployment.Namespace}
        podsList := &amp;corev1.PodList{}
        err := r.List(context.TODO(), podsList, listOptions)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, pod := range podsList.Items </span><span class="cov8" title="1">{
                if strings.HasPrefix(pod.Name, controllerDeployment.Name) </span><span class="cov8" title="1">{
                        return &amp;pod, nil
                }</span>
        }

        <span class="cov0" title="0">err = errors.NewNotFound(schema.GroupResource{Group: "", Resource: "pods"}, "controller pod")
        return nil, err</span>
}

func (r *IBMObjectCSIReconciler) areAllPodImagesSynced(controllerDeployment *appsv1.Deployment, controllerPod *corev1.Pod) bool <span class="cov8" title="1">{
        logger := csiLog.WithName("areAllPodImagesSynced")
        deploymentContainers := controllerDeployment.Spec.Template.Spec.Containers
        podContainers := controllerPod.Spec.Containers
        if len(deploymentContainers) != len(podContainers) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(deploymentContainers); i++ </span><span class="cov8" title="1">{
                deploymentImage := deploymentContainers[i].Image
                podImage := podContainers[i].Image

                if deploymentImage != podImage </span><span class="cov8" title="1">{
                        logger.Info("csi controller image not in sync",
                                "deploymentImage", deploymentImage, "podImage", podImage)
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (r *IBMObjectCSIReconciler) isControllerReady(controller *appsv1.Deployment) bool <span class="cov8" title="1">{
        return controller.Status.ReadyReplicas == controller.Status.Replicas
}</span>

func (r *IBMObjectCSIReconciler) isNodeReady(node *appsv1.DaemonSet) bool <span class="cov8" title="1">{
        return node.Status.DesiredNumberScheduled == node.Status.NumberAvailable
}</span>

func (r *IBMObjectCSIReconciler) getNodeDaemonSet(instance *crutils.IBMObjectCSI) (*appsv1.DaemonSet, error) <span class="cov8" title="1">{
        node := &amp;appsv1.DaemonSet{}
        err := r.Get(context.TODO(), types.NamespacedName{
                Name:      constants.GetResourceName(constants.CSINode),
                Namespace: instance.Namespace,
        }, node)
        return node, err
}</span>

func (r *IBMObjectCSIReconciler) getControllerDeployment(instance *crutils.IBMObjectCSI) (*appsv1.Deployment, error) <span class="cov8" title="1">{
        controllerDeployment := &amp;appsv1.Deployment{}
        err := r.Get(context.TODO(), types.NamespacedName{
                Name:      constants.GetResourceName(constants.CSIController),
                Namespace: instance.Namespace,
        }, controllerDeployment)
        return controllerDeployment, err
}</span>

func (r *IBMObjectCSIReconciler) reconcileClusterRoleBinding(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        clusterRoleBindings := r.getClusterRoleBindings(instance)
        return r.ControllerHelper.ReconcileClusterRoleBinding(clusterRoleBindings)
}</span>

func (r *IBMObjectCSIReconciler) reconcileStorageClasses(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        logger := csiLog.WithName("reconcileStorageClasses")
        logger.Info("Entry")
        defer logger.Info("Exit")
        storageClasses := r.getStorageClasses(instance)
        logger.Info("storageclasses to be reonciled", "count", len(storageClasses))
        return r.ControllerHelper.ReconcileStorageClasses(storageClasses)
}</span>

func (r *IBMObjectCSIReconciler) reconcileClusterRole(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        clusterRoles := r.getClusterRoles(instance)
        return r.ControllerHelper.ReconcileClusterRole(clusterRoles)
}</span>

func (r *IBMObjectCSIReconciler) reconcileServiceAccount(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        logger := csiLog.WithValues("Resource Type", "ServiceAccount")

        controller := instance.GenerateControllerServiceAccount()
        node := instance.GenerateNodeServiceAccount()

        controllerServiceAccountName := constants.GetResourceName(constants.CSIControllerServiceAccount)
        nodeServiceAccountName := constants.GetResourceName(constants.CSINodeServiceAccount)

        for _, sa := range []*corev1.ServiceAccount{
                controller,
                node,
        } </span><span class="cov8" title="1">{
                if err := controllerutil.SetControllerReference(instance.Unwrap(), sa, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">found := &amp;corev1.ServiceAccount{}
                err := r.Get(context.TODO(), types.NamespacedName{
                        Name:      sa.Name,
                        Namespace: sa.Namespace,
                }, found)
                if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        logger.Info("Creating a new ServiceAccount", "Namespace", sa.GetNamespace(), "Name", sa.GetName())
                        err = r.Create(context.TODO(), sa)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">nodeDaemonSet, err := r.getNodeDaemonSet(instance)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if controllerServiceAccountName == sa.Name </span><span class="cov8" title="1">{
                                rErr := r.restartControllerPod(logger, instance)
                                if rErr != nil </span><span class="cov8" title="1">{
                                        return rErr
                                }</span>
                        }
                        <span class="cov8" title="1">if nodeServiceAccountName == sa.Name </span><span class="cov8" title="1">{
                                logger.Info("node rollout requires restart",
                                        "DesiredNumberScheduled", nodeDaemonSet.Status.DesiredNumberScheduled,
                                        "NumberAvailable", nodeDaemonSet.Status.NumberAvailable)
                                logger.Info("csi node stopped being ready - restarting it")
                                rErr := r.rolloutRestartNode(nodeDaemonSet)
                                if rErr != nil </span><span class="cov0" title="0">{
                                        return rErr
                                }</span>
                        }
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        logger.Error(err, "Failed to get ServiceAccount", "Name", sa.GetName())
                        return err
                }</span> else<span class="cov8" title="1"> {
                        logger.Info("ServiceAccount already exists", "Namespace", sa.GetNamespace(), "Name", sa.GetName())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *IBMObjectCSIReconciler) rolloutRestartNode(node *appsv1.DaemonSet) error <span class="cov8" title="1">{
        restartedAt := fmt.Sprintf("%s/restartedAt", constants.APIGroup)
        timestamp := time.Now().String()
        node.Spec.Template.ObjectMeta.Annotations[restartedAt] = timestamp
        return r.Update(context.TODO(), node)
}</span>

func (r *IBMObjectCSIReconciler) restartControllerPod(logger logr.Logger, instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        controllerDeployment, err := r.getControllerDeployment(instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">logger.Info("controller requires restart",
                "ReadyReplicas", controllerDeployment.Status.ReadyReplicas,
                "Replicas", controllerDeployment.Status.Replicas)
        logger.Info("restarting csi controller")

        controllerPod, err := r.getControllerPod(controllerDeployment)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">logger.Error(err, "failed to get controller pod")
                return err</span>
        }

        <span class="cov8" title="1">return r.restartControllerPodfromDeployment(logger, controllerDeployment, controllerPod)</span>
}

func (r *IBMObjectCSIReconciler) reconcileCSIDriver(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        logger := csiLog.WithValues("Resource Type", "CSIDriver")

        cd := instance.GenerateCSIDriver()
        found := &amp;storagev1.CSIDriver{}
        err := r.Get(context.TODO(), types.NamespacedName{Name: cd.Name, Namespace: ""}, found)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        logger.Info("Creating a new CSIDriver", "Name", cd.GetName())
                        err = r.Create(context.TODO(), cd)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">logger.Info("CSIDriver created", "Namespace", cd.GetNamespace(), "Name", cd.GetName())
                        return nil</span>
                }
                <span class="cov8" title="1">logger.Error(err, "Failed to get CSIDriver", "Name", cd.GetName())
                return err</span>
        }
        <span class="cov8" title="1">logger.Info("CSIDriver already exists", "Namespace", cd.GetNamespace(), "Name", cd.GetName())
        return nil</span>
}

func (r *IBMObjectCSIReconciler) deleteCSIDriver(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        logger := csiLog.WithName("deleteCSIDriver")

        csiDriver := instance.GenerateCSIDriver()
        found := &amp;storagev1.CSIDriver{}
        err := r.Get(context.TODO(), types.NamespacedName{
                Name:      csiDriver.Name,
                Namespace: csiDriver.Namespace,
        }, found)
        if err == nil </span><span class="cov8" title="1">{
                logger.Info("deleting CSIDriver", "Name", csiDriver.GetName())
                if err := r.Delete(context.TODO(), found); err != nil </span><span class="cov8" title="1">{
                        logger.Error(err, "failed to delete CSIDriver", "Name", csiDriver.GetName())
                        return err
                }</span>
        } else<span class="cov8" title="1"> if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                logger.Error(err, "failed to get CSIDriver", "Name", csiDriver.GetName())
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *IBMObjectCSIReconciler) deleteClusterRoleBindings(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        clusterRoleBindings := r.getClusterRoleBindings(instance)
        return r.ControllerHelper.DeleteClusterRoleBindings(clusterRoleBindings)
}</span>

func (r *IBMObjectCSIReconciler) deleteStorageClasses(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        storageClasses := r.getStorageClasses(instance)
        return r.ControllerHelper.DeleteStorageClasses(storageClasses)
}</span>

func (r *IBMObjectCSIReconciler) getClusterRoleBindings(instance *crutils.IBMObjectCSI) []*rbacv1.ClusterRoleBinding <span class="cov8" title="1">{
        externalProvisioner := instance.GenerateExternalProvisionerClusterRoleBinding()
        controllerSCC := instance.GenerateSCCForControllerClusterRoleBinding()
        nodeSCC := instance.GenerateSCCForNodeClusterRoleBinding()

        return []*rbacv1.ClusterRoleBinding{
                externalProvisioner,
                controllerSCC,
                nodeSCC,
        }
}</span>

func (r *IBMObjectCSIReconciler) getStorageClasses(instance *crutils.IBMObjectCSI) []*storagev1.StorageClass <span class="cov8" title="1">{
        var requiredRegion string

        s3Provider := r.ControllerHelper.GetS3Provider()

        k8sSCs := []*storagev1.StorageClass{}
        cosSCs := []string{}

        reclaimPolicys := []corev1.PersistentVolumeReclaimPolicy{
                corev1.PersistentVolumeReclaimRetain,
                corev1.PersistentVolumeReclaimDelete}

        if len(s3Provider) == 0 || s3Provider == constants.S3ProviderIBM </span><span class="cov8" title="1">{
                r.ControllerHelper.SetIBMCosEP()
                cosSCs = r.ControllerHelper.GetIBMCosSC()
                requiredRegion = r.ControllerHelper.GetRegion()
        }</span> else<span class="cov8" title="1"> {
                r.ControllerHelper.SetS3ProviderEP()
                cosSCs = append(cosSCs, "standard")
                requiredRegion = r.ControllerHelper.S3ProviderRegion
        }</span>
        <span class="cov8" title="1">cosEP := r.ControllerHelper.GetCosEP()

        for _, sc := range cosSCs </span><span class="cov8" title="1">{
                for _, rp := range reclaimPolicys </span><span class="cov8" title="1">{
                        rcloneK8sSc := instance.GenerateRcloneSC(crutils.SCInputParams{
                                ReclaimPolicy:   rp,
                                S3Provider:      s3Provider,
                                Region:          requiredRegion,
                                COSEndpoint:     cosEP,
                                COSStorageClass: sc,
                        })
                        k8sSCs = append(k8sSCs, rcloneK8sSc)

                        s3fsK8sSc := instance.GenerateS3fsSC(crutils.SCInputParams{
                                ReclaimPolicy:   rp,
                                S3Provider:      s3Provider,
                                Region:          requiredRegion,
                                COSEndpoint:     cosEP,
                                COSStorageClass: sc,
                        })
                        k8sSCs = append(k8sSCs, s3fsK8sSc)
                }</span>
        }
        <span class="cov8" title="1">return k8sSCs</span>
}

func (r *IBMObjectCSIReconciler) deleteClusterRoles(instance *crutils.IBMObjectCSI) error <span class="cov8" title="1">{
        clusterRoles := r.getClusterRoles(instance)
        return r.ControllerHelper.DeleteClusterRoles(clusterRoles)
}</span>

func (r *IBMObjectCSIReconciler) getClusterRoles(instance *crutils.IBMObjectCSI) []*rbacv1.ClusterRole <span class="cov8" title="1">{
        externalProvisioner := instance.GenerateExternalProvisionerClusterRole()
        controllerSCC := instance.GenerateSCCForControllerClusterRole()
        nodeSCC := instance.GenerateSCCForNodeClusterRole()

        return []*rbacv1.ClusterRole{
                externalProvisioner,
                controllerSCC,
                nodeSCC,
        }
}</span>

func checkIfupdateCRFromConfigMapRequired(instance *objectdriverv1alpha1.IBMObjectCSI, cm *corev1.ConfigMap) bool <span class="cov8" title="1">{
        crUpdateRequired := false

        if val, ok := cm.Data[constants.NodeServerCPURequestCMKey]; ok </span><span class="cov0" title="0">{
                if instance.Spec.Node.Resources.Requests.CPU != val </span><span class="cov0" title="0">{
                        instance.Spec.Node.Resources.Requests.CPU = val
                        crUpdateRequired = true
                }</span>
        }
        <span class="cov8" title="1">if val, ok := cm.Data[constants.NodeServerMemoryRequestCMKey]; ok </span><span class="cov0" title="0">{
                if instance.Spec.Node.Resources.Requests.Memory != val </span><span class="cov0" title="0">{
                        instance.Spec.Node.Resources.Requests.Memory = val
                        crUpdateRequired = true
                }</span>
        }
        <span class="cov8" title="1">if val, ok := cm.Data[constants.NodeServerCPULimitCMKey]; ok </span><span class="cov0" title="0">{
                if instance.Spec.Node.Resources.Limits.CPU != val </span><span class="cov0" title="0">{
                        instance.Spec.Node.Resources.Limits.CPU = val
                        crUpdateRequired = true
                }</span>
        }
        <span class="cov8" title="1">if val, ok := cm.Data[constants.NodeServerMemoryLimitCMKey]; ok </span><span class="cov0" title="0">{
                if instance.Spec.Node.Resources.Limits.Memory != val </span><span class="cov0" title="0">{
                        instance.Spec.Node.Resources.Limits.Memory = val
                        crUpdateRequired = true
                }</span>
        }

        <span class="cov8" title="1">if val, ok := cm.Data[constants.MaxVolumesPerNodeCMKey]; ok </span><span class="cov8" title="1">{
                if instance.Spec.Node.MaxVolumesPerNode != val </span><span class="cov8" title="1">{
                        instance.Spec.Node.MaxVolumesPerNode = val
                        crUpdateRequired = true
                }</span>
        }
        <span class="cov8" title="1">return crUpdateRequired</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *IBMObjectCSIReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;objectdriverv1alpha1.IBMObjectCSI{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;appsv1.DaemonSet{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;storagev1.StorageClass{}).
                Watches(&amp;corev1.ConfigMap{}, &amp;handler.EnqueueRequestForObject{}, builder.WithPredicates(configMapPredicate())).
                Complete(r)
}</span>

func configMapPredicate() predicate.Predicate <span class="cov8" title="1">{
        logger := csiLog.WithName("configMapPredicate")
        triggerReconcile := predicate.Funcs{
                CreateFunc: func(e event.CreateEvent) bool </span><span class="cov0" title="0">{
                        configmap := e.Object.(*corev1.ConfigMap)
                        if configmap.Namespace == constants.ParamsConfigMapNamespace &amp;&amp; configmap.Name == constants.ParamsConfigMap </span><span class="cov0" title="0">{
                                logger.Info("Configmap created", "name", configmap.Name, "namespace", configmap.Namespace)
                                return true
                        }</span>
                        <span class="cov0" title="0">return false</span>
                },
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                        configmap := e.ObjectNew.(*corev1.ConfigMap)
                        if configmap.Namespace == constants.ParamsConfigMapNamespace &amp;&amp; configmap.Name == constants.ParamsConfigMap </span><span class="cov0" title="0">{
                                logger.Info("Update event on the configmap", "name", configmap.Name, "namespace", configmap.Namespace)
                                return true
                        }</span>
                        <span class="cov0" title="0">return false</span>
                },
                DeleteFunc: func(event.DeleteEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                GenericFunc: func(event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
        }
        <span class="cov8" title="1">return triggerReconcile</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package common ...
package common

import (
        "k8s.io/apimachinery/pkg/labels"
)

// GetSelectorLabels ...
func GetSelectorLabels(component string) labels.Set <span class="cov0" title="0">{
        return labels.Set{
                "app.kubernetes.io/component": component,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package crutils ...
package crutils

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Instance ...
type Instance interface {
        GetLabels() labels.Set
        GetObjectKind() schema.ObjectKind
}

// GetImagePullSecrets ...
func GetImagePullSecrets(imagePullSecrets []string) []corev1.LocalObjectReference <span class="cov0" title="0">{
        secrets := []corev1.LocalObjectReference{}
        if len(imagePullSecrets) &gt; 0 </span><span class="cov0" title="0">{
                for _, secretName := range imagePullSecrets </span><span class="cov0" title="0">{
                        secrets = append(secrets, corev1.LocalObjectReference{Name: secretName})
                }</span>
        }
        <span class="cov0" title="0">return secrets</span>
}

type SCInputParams struct {
        ReclaimPolicy   corev1.PersistentVolumeReclaimPolicy
        S3Provider      string
        Region          string
        COSEndpoint     string
        COSStorageClass string
        IsCrossRegional bool
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package crutils ...
package crutils

import (
        "fmt"

        objectdriverv1alpha1 "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/common"
        csiversion "github.com/IBM/ibm-object-csi-driver-operator/version"
        "k8s.io/apimachinery/pkg/labels"
)

// IBMObjectCSI is the wrapper for objectdriverv1alpha1.IBMObjectCSI type
type IBMObjectCSI struct {
        *objectdriverv1alpha1.IBMObjectCSI
}

// New returns a wrapper for objectdriverv1.IBMObjectCSI
func New(c *objectdriverv1alpha1.IBMObjectCSI) *IBMObjectCSI <span class="cov0" title="0">{
        return &amp;IBMObjectCSI{
                IBMObjectCSI: c,
        }
}</span>

// Unwrap returns the objectdriverv1.IBMObjectCSI object
func (c *IBMObjectCSI) Unwrap() *objectdriverv1alpha1.IBMObjectCSI <span class="cov0" title="0">{
        return c.IBMObjectCSI
}</span>

// GetLabels returns all the labels to be set on all resources
func (c *IBMObjectCSI) GetLabels() labels.Set <span class="cov0" title="0">{
        labels := labels.Set{
                "app.kubernetes.io/name":       constants.CSIDriverName,
                "app.kubernetes.io/instance":   c.Name,
                "app.kubernetes.io/version":    csiversion.Version,
                "app.kubernetes.io/part-of":    constants.CSIDriverName,
                "app.kubernetes.io/managed-by": constants.CSIOperatorName,
                "product":                      constants.CSIDriverName,
                "release":                      fmt.Sprintf("v%s", csiversion.Version),
        }

        if c.Labels != nil </span><span class="cov0" title="0">{
                for k, v := range c.Labels </span><span class="cov0" title="0">{
                        if !labels.Has(k) </span><span class="cov0" title="0">{
                                labels[k] = v
                        }</span>
                }
        }

        <span class="cov0" title="0">return labels</span>
}

// GetAnnotations returns all the annotations to be set on all resources
func (c *IBMObjectCSI) GetAnnotations() labels.Set <span class="cov0" title="0">{
        labels := labels.Set{
                "productID":      constants.CSIDriverName,
                "productName":    constants.CSIDriverName,
                "productVersion": csiversion.Version,
        }

        if c.Annotations != nil </span><span class="cov0" title="0">{
                for k, v := range c.Annotations </span><span class="cov0" title="0">{
                        if !labels.Has(k) </span><span class="cov0" title="0">{
                                labels[k] = v
                        }</span>
                }
        }
        <span class="cov0" title="0">return labels</span>
}

// GetCSINodeSelectorLabels ...
func (c *IBMObjectCSI) GetCSINodeSelectorLabels() labels.Set <span class="cov0" title="0">{
        return common.GetSelectorLabels(constants.CSINode)
}</span>

// GetCSINodePodLabels ...
func (c *IBMObjectCSI) GetCSINodePodLabels() labels.Set <span class="cov0" title="0">{
        return labels.Merge(c.GetLabels(), c.GetCSINodeSelectorLabels())
}</span>

// GetCSINodeImage ...
func (c *IBMObjectCSI) GetCSINodeImage() string <span class="cov0" title="0">{
        if c.Spec.Node.Tag == "" </span><span class="cov0" title="0">{
                return c.Spec.Node.Repository
        }</span>
        <span class="cov0" title="0">return c.Spec.Node.Repository + ":" + c.Spec.Node.Tag</span>
}

// GetCSIControllerSelectorLabels ...
func (c *IBMObjectCSI) GetCSIControllerSelectorLabels() labels.Set <span class="cov0" title="0">{
        return common.GetSelectorLabels(constants.CSIController)
}</span>

// GetCSIControllerPodLabels ...
func (c *IBMObjectCSI) GetCSIControllerPodLabels() labels.Set <span class="cov0" title="0">{
        return labels.Merge(c.GetLabels(), c.GetCSIControllerSelectorLabels())
}</span>

// GetCSIControllerImage ...
func (c *IBMObjectCSI) GetCSIControllerImage() string <span class="cov0" title="0">{
        if c.Spec.Controller.Tag == "" </span><span class="cov0" title="0">{
                return c.Spec.Controller.Repository
        }</span>
        <span class="cov0" title="0">return c.Spec.Controller.Repository + ":" + c.Spec.Controller.Tag</span>
}

// GetCSIControllerResourceRequests ...
func (c *IBMObjectCSI) GetCSIControllerResourceRequests() *objectdriverv1alpha1.ResourcesSpec <span class="cov0" title="0">{
        return &amp;c.Spec.Controller.Resources
}</span>

// GetCSINodeResourceRequests ...
func (c *IBMObjectCSI) GetCSINodeResourceRequests() *objectdriverv1alpha1.ResourcesSpec <span class="cov0" title="0">{
        return &amp;c.Spec.Node.Resources
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package crutils

import (
        "context"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type K8sResourceOps struct {
        client.Client
        Ctx       context.Context
        Namespace string
}

func (op *K8sResourceOps) GetDeployment(name string) (*appsv1.Deployment, error) <span class="cov0" title="0">{
        deployment := &amp;appsv1.Deployment{}
        err := op.Get(op.Ctx, types.NamespacedName{Name: name, Namespace: op.Namespace}, deployment)
        return deployment, err
}</span>

func (op *K8sResourceOps) ListDeployment() (*appsv1.DeploymentList, error) <span class="cov0" title="0">{
        var listOptions = &amp;client.ListOptions{Namespace: op.Namespace}
        deploymentList := &amp;appsv1.DeploymentList{}
        err := op.List(op.Ctx, deploymentList, listOptions)
        return deploymentList, err
}</span>

func (op *K8sResourceOps) DeletePod(pod *corev1.Pod) error <span class="cov0" title="0">{
        var zero int64
        var deleteOptions = &amp;client.DeleteOptions{GracePeriodSeconds: &amp;zero}
        err := op.Delete(op.Ctx, pod, deleteOptions)
        return err
}</span>

func (op *K8sResourceOps) ListPod() (*corev1.PodList, error) <span class="cov0" title="0">{
        var listOptions = &amp;client.ListOptions{Namespace: op.Namespace}
        podList := &amp;corev1.PodList{}
        err := op.List(op.Ctx, podList, listOptions)
        return podList, err
}</span>

func (op *K8sResourceOps) ListPVC() (*corev1.PersistentVolumeClaimList, error) <span class="cov0" title="0">{
        var listOptions = &amp;client.ListOptions{Namespace: op.Namespace}
        pvcList := &amp;corev1.PersistentVolumeClaimList{}
        err := op.List(op.Ctx, pvcList, listOptions)
        return pvcList, err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package crutils ...
package crutils

import (
        "fmt"

        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        storagev1 "k8s.io/api/storage/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util"
)

// GenerateCSIDriver ...
func (c *IBMObjectCSI) GenerateCSIDriver() *storagev1.CSIDriver <span class="cov0" title="0">{
        defaultFSGroupPolicy := storagev1.FileFSGroupPolicy
        return &amp;storagev1.CSIDriver{
                ObjectMeta: metav1.ObjectMeta{
                        Name: constants.DriverName,
                        Labels: map[string]string{
                                "app.kubernetes.io/name":       constants.ObjectCSIDriver,
                                "app.kubernetes.io/part-of":    constants.CSIDriverName,
                                "app.kubernetes.io/managed-by": constants.CSIOperatorName,
                        },
                },
                Spec: storagev1.CSIDriverSpec{
                        AttachRequired: util.False(),
                        PodInfoOnMount: util.True(),
                        FSGroupPolicy:  &amp;defaultFSGroupPolicy,
                },
        }
}</span>

// GenerateControllerServiceAccount ...
func (c *IBMObjectCSI) GenerateControllerServiceAccount() *corev1.ServiceAccount <span class="cov0" title="0">{
        return getServiceAccount(c, constants.CSIControllerServiceAccount)
}</span>

// GenerateNodeServiceAccount ...
func (c *IBMObjectCSI) GenerateNodeServiceAccount() *corev1.ServiceAccount <span class="cov0" title="0">{
        return getServiceAccount(c, constants.CSINodeServiceAccount)
}</span>

func getServiceAccount(c *IBMObjectCSI, serviceAccountResourceName string) *corev1.ServiceAccount <span class="cov0" title="0">{
        secrets := GetImagePullSecrets(c.Spec.ImagePullSecrets)
        return &amp;corev1.ServiceAccount{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      constants.GetResourceName(serviceAccountResourceName),
                        Namespace: c.Namespace,
                        Labels:    c.GetLabels(),
                },
                ImagePullSecrets: secrets,
        }
}</span>

// GenerateExternalProvisionerClusterRole ...
func (c *IBMObjectCSI) GenerateExternalProvisionerClusterRole() *rbacv1.ClusterRole <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   constants.GetResourceName(constants.ExternalProvisionerClusterRole),
                        Labels: constants.CommonCSIResourceLabels,
                },
                Rules: []rbacv1.PolicyRule{
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.SecretsResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.PersistentVolumesResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList, constants.VerbWatch, constants.VerbPatch, constants.VerbCreate, constants.VerbDelete},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.PersistentVolumeClaimsResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList, constants.VerbWatch, constants.VerbUpdate},
                        },
                        {
                                APIGroups: []string{constants.StorageAPIGroup},
                                Resources: []string{constants.StorageClassesResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList, constants.VerbWatch},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.EventsResource},
                                Verbs:     []string{constants.VerbList, constants.VerbWatch, constants.VerbCreate, constants.VerbUpdate, constants.VerbPatch},
                        },
                        {
                                APIGroups: []string{constants.StorageAPIGroup},
                                Resources: []string{constants.CSINodesResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList, constants.VerbWatch},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.NodesResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList, constants.VerbWatch},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.ConfigMapResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList},
                        },
                },
        }
}</span>

// GenerateExternalProvisionerClusterRoleBinding ...
func (c *IBMObjectCSI) GenerateExternalProvisionerClusterRoleBinding() *rbacv1.ClusterRoleBinding <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   constants.GetResourceName(constants.ExternalProvisionerClusterRoleBinding),
                        Labels: constants.CommonCSIResourceLabels,
                },
                Subjects: []rbacv1.Subject{
                        {
                                Kind:      "ServiceAccount",
                                Name:      constants.GetResourceName(constants.CSIControllerServiceAccount),
                                Namespace: c.Namespace,
                        },
                },
                RoleRef: rbacv1.RoleRef{
                        Kind:     "ClusterRole",
                        Name:     constants.GetResourceName(constants.ExternalProvisionerClusterRole),
                        APIGroup: constants.RbacAuthorizationAPIGroup,
                },
        }
}</span>

// GenerateSCCForControllerClusterRole ...
func (c *IBMObjectCSI) GenerateSCCForControllerClusterRole() *rbacv1.ClusterRole <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   constants.GetResourceName(constants.CSIControllerSCCClusterRole),
                        Labels: constants.CommonCSIResourceLabels,
                },
                Rules: []rbacv1.PolicyRule{
                        {
                                APIGroups:     []string{constants.SecurityOpenshiftAPIGroup},
                                Resources:     []string{constants.SecurityContextConstraintsResource},
                                ResourceNames: []string{"anyuid"},
                                Verbs:         []string{"use"},
                        },
                },
        }
}</span>

// GenerateSCCForControllerClusterRoleBinding ...
func (c *IBMObjectCSI) GenerateSCCForControllerClusterRoleBinding() *rbacv1.ClusterRoleBinding <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   constants.GetResourceName(constants.CSIControllerSCCClusterRoleBinding),
                        Labels: constants.CommonCSIResourceLabels,
                },
                Subjects: []rbacv1.Subject{
                        {
                                Kind:      "ServiceAccount",
                                Name:      constants.GetResourceName(constants.CSIControllerServiceAccount),
                                Namespace: c.Namespace,
                        },
                },
                RoleRef: rbacv1.RoleRef{
                        Kind:     "ClusterRole",
                        Name:     constants.GetResourceName(constants.CSIControllerSCCClusterRole),
                        APIGroup: constants.RbacAuthorizationAPIGroup,
                },
        }
}</span>

// GenerateSCCForNodeClusterRole ...
func (c *IBMObjectCSI) GenerateSCCForNodeClusterRole() *rbacv1.ClusterRole <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   constants.GetResourceName(constants.CSINodeSCCClusterRole),
                        Labels: constants.CommonCSIResourceLabels,
                },
                Rules: []rbacv1.PolicyRule{
                        {
                                APIGroups:     []string{constants.SecurityOpenshiftAPIGroup},
                                Resources:     []string{constants.SecurityContextConstraintsResource},
                                ResourceNames: []string{"privileged"},
                                Verbs:         []string{"use"},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.NodesResource},
                                Verbs:     []string{constants.VerbGet},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.PersistentVolumesResource, constants.SecretsResource},
                                Verbs:     []string{constants.VerbGet},
                        },
                        {
                                APIGroups: []string{""},
                                Resources: []string{constants.ConfigMapResource},
                                Verbs:     []string{constants.VerbGet, constants.VerbList},
                        },
                },
        }
}</span>

// GenerateSCCForNodeClusterRoleBinding ...
func (c *IBMObjectCSI) GenerateSCCForNodeClusterRoleBinding() *rbacv1.ClusterRoleBinding <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   constants.GetResourceName(constants.CSINodeSCCClusterRoleBinding),
                        Labels: constants.CommonCSIResourceLabels,
                },
                Subjects: []rbacv1.Subject{
                        {
                                Kind:      "ServiceAccount",
                                Name:      constants.GetResourceName(constants.CSINodeServiceAccount),
                                Namespace: c.Namespace,
                        },
                },
                RoleRef: rbacv1.RoleRef{
                        Kind:     "ClusterRole",
                        Name:     constants.GetResourceName(constants.CSINodeSCCClusterRole),
                        APIGroup: constants.RbacAuthorizationAPIGroup,
                },
        }
}</span>

// Generates3fsSC ...
func (c *IBMObjectCSI) GenerateS3fsSC(scInputParams SCInputParams) *storagev1.StorageClass <span class="cov0" title="0">{
        var storageClassName, locationConstraint string
        if scInputParams.S3Provider == constants.S3ProviderIBM </span><span class="cov0" title="0">{
                locationConstraint = fmt.Sprintf("%s-%s", scInputParams.Region, scInputParams.COSStorageClass)
        }</span> else<span class="cov0" title="0"> {
                locationConstraint = scInputParams.Region
        }</span>

        // "ibm-object-storage-standard-s3fs"
        <span class="cov0" title="0">storageClassName = fmt.Sprintf("%s-%s-s3fs", constants.StorageClassPrefix, scInputParams.COSStorageClass)
        if scInputParams.ReclaimPolicy == corev1.PersistentVolumeReclaimRetain </span><span class="cov0" title="0">{
                storageClassName = fmt.Sprintf("%s-%s", storageClassName, constants.RetainPolicyTag) // "ibm-object-storage-standard-s3fs-retain"
        }</span>

        <span class="cov0" title="0">mountOptions := []string{
                "multipart_size=52",
                "multireq_max=20",
                "max_dirty_data=5120",
                "parallel_count=20",
                "max_stat_cache_size=100000",
                "retries=5",
                "kernel_cache",
        }

        return &amp;storagev1.StorageClass{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   storageClassName,
                        Labels: constants.CommonCSIResourceLabels,
                },
                Provisioner:   constants.DriverName,
                ReclaimPolicy: &amp;scInputParams.ReclaimPolicy,
                MountOptions:  mountOptions,
                Parameters: map[string]string{
                        "mounter":            "s3fs",
                        "client":             "awss3",
                        "cosEndpoint":        scInputParams.COSEndpoint,
                        "locationConstraint": locationConstraint,
                        "csi.storage.k8s.io/node-publish-secret-name":      "${pvc.annotations['cos.csi.driver/secret']}",
                        "csi.storage.k8s.io/node-publish-secret-namespace": "${pvc.namespace}",
                },
        }</span>
}

// GenerateRcloneSC ...
func (c *IBMObjectCSI) GenerateRcloneSC(scInputParams SCInputParams) *storagev1.StorageClass <span class="cov0" title="0">{
        var storageClassName, locationConstraint string

        // "ibm-object-storage-standard-rclone"
        storageClassName = fmt.Sprintf("%s-%s-rclone", constants.StorageClassPrefix, scInputParams.COSStorageClass)
        if scInputParams.ReclaimPolicy == corev1.PersistentVolumeReclaimRetain </span><span class="cov0" title="0">{
                storageClassName = fmt.Sprintf("%s-%s", storageClassName, constants.RetainPolicyTag) // "ibm-object-storage-standard-rclone-retain"
        }</span>

        <span class="cov0" title="0">if scInputParams.S3Provider == constants.S3ProviderIBM </span><span class="cov0" title="0">{
                locationConstraint = fmt.Sprintf("%s-%s", scInputParams.Region, scInputParams.COSStorageClass)
        }</span> else<span class="cov0" title="0"> {
                locationConstraint = scInputParams.Region
        }</span>

        <span class="cov0" title="0">return &amp;storagev1.StorageClass{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   storageClassName,
                        Labels: constants.CommonCSIResourceLabels,
                },
                Provisioner:   constants.DriverName,
                ReclaimPolicy: &amp;scInputParams.ReclaimPolicy,
                MountOptions: []string{
                        "acl=private",
                        "bucket_acl=private",
                        "upload_cutoff=100Mi",
                        "chunk_size=16Mi",
                        "max_upload_parts=1000",
                        "upload_concurrency=8",
                        "multi_thread_streams=8",
                        "disable_checksum=true",
                },
                Parameters: map[string]string{
                        "mounter":            "rclone",
                        "client":             "awss3",
                        "cosEndpoint":        scInputParams.COSEndpoint,
                        "locationConstraint": locationConstraint,
                        "csi.storage.k8s.io/node-publish-secret-name":      "${pvc.annotations['cos.csi.driver/secret']}",
                        "csi.storage.k8s.io/node-publish-secret-namespace": "${pvc.namespace}",
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package controllers ...
package controllers

import (
        "regexp"
        "strings"
)

// LogEntry ...
type LogEntry struct {
        PID       string
        Timestamp string
        File      string
        Message   string
}

func getLogEntry(log string) *LogEntry <span class="cov8" title="1">{
        logPattern := regexp.MustCompile(`^([A-Z]\d{4} \d{2}:\d{2}:\d{2}\.\d{6})\s+\d+\s+([\w/.-]+:\d+)\]\s+(.*)$`)

        matches := logPattern.FindStringSubmatch(log)

        if len(matches) == 4 </span><span class="cov8" title="1">{
                pid := matches[0]
                timestamp := matches[1]
                file := matches[2]
                message := matches[3]

                return &amp;LogEntry{
                        PID:       pid,
                        Timestamp: timestamp,
                        File:      file,
                        Message:   message,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func parseLogs(nodePodLogs string) map[string]string <span class="cov8" title="1">{
        logs := strings.Split(strings.TrimSpace(nodePodLogs), "\n")

        volumesStats := map[string]string{}

        for _, log := range logs </span><span class="cov8" title="1">{
                logEntry := getLogEntry(log)

                if logEntry != nil </span><span class="cov8" title="1">{
                        logMsg := logEntry.Message

                        regexToGetMap := regexp.MustCompile(`map\[(.*?)\]`)
                        matches := regexToGetMap.FindStringSubmatch(logMsg)

                        if len(matches) == 2 </span><span class="cov8" title="1">{
                                mapContent := matches[1]

                                getVolumeID := regexp.MustCompile(`VolumeId:\S+`).FindStringSubmatch(mapContent)
                                if len(getVolumeID) != 0 </span><span class="cov8" title="1">{
                                        volumeID := strings.Split(getVolumeID[0], ":")[1]

                                        getErrMsg := strings.ReplaceAll(mapContent, getVolumeID[0], "")
                                        errMsg := strings.Split(getErrMsg, ":")[1]

                                        volumesStats[volumeID] = errMsg
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return volumesStats</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package controllers ...
package controllers

import (
        "bytes"
        "context"
        "io"
        "strings"
        "time"

        objectdriverv1alpha1 "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util"
        "github.com/go-logr/logr"
        "golang.org/x/exp/maps"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// RecoverStaleVolumeReconciler reconciles a RecoverStaleVolume object
type RecoverStaleVolumeReconciler struct {
        client.Client
        Scheme *runtime.Scheme
        IsTest bool
}

// KubernetesClient ...
type KubernetesClient struct {
        Clientset kubernetes.Interface
}

var staleVolLog = logf.Log.WithName("recoverstalevolume_controller")
var kubeClient = createK8sClient

//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=recoverstalevolumes,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=recoverstalevolumes/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=objectdriver.csi.ibm.com,resources=recoverstalevolumes/finalizers,verbs=update
//+kubebuilder:rbac:groups="",resources=pods/log,verbs=get

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the RecoverStaleVolume object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.14.4/pkg/reconcile
func (r *RecoverStaleVolumeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        reqLogger := staleVolLog.WithValues("Request.Namespace", req.Namespace, "Request.Name", req.Name)
        reqLogger.Info("Reconciling RecoverStaleVolume")

        // Fetch RecoverStaleVolume instance
        instance := &amp;objectdriverv1alpha1.RecoverStaleVolume{}
        err := r.Get(ctx, req.NamespacedName, instance)
        if err != nil </span><span class="cov8" title="1">{
                if k8serr.IsNotFound(err) </span><span class="cov8" title="1">{
                        reqLogger.Info("RecoverStaleVolume resource not found. Ignoring since object must be deleted")
                        return ctrl.Result{}, nil
                }</span>
                // Error reading the object.
                <span class="cov8" title="1">reqLogger.Error(err, "failed to get RecoverStaleVolume resource")
                return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">var logTailLines = instance.Spec.LogHistory
        if logTailLines == 0 </span><span class="cov8" title="1">{
                logTailLines = int64(constants.DefaultLogTailLines)
        }</span>
        <span class="cov8" title="1">reqLogger.Info("Tail Log Lines to fetch", "number", logTailLines)

        for _, data := range instance.Spec.Data </span><span class="cov8" title="1">{
                namespace := data.Namespace
                deployments := util.Remove(data.Deployments, "")
                reqLogger.Info("Data Requested", "namespace", namespace, "deployments", deployments)

                k8sOps := &amp;crutils.K8sResourceOps{
                        Client:    r.Client,
                        Ctx:       ctx,
                        Namespace: namespace,
                }

                // If applications are not set, then fetch all deployments from given ns
                if len(deployments) == 0 </span><span class="cov8" title="1">{
                        deploymentsList, err := k8sOps.ListDeployment()
                        if err != nil </span><span class="cov8" title="1">{
                                reqLogger.Error(err, "failed to get deployment list")
                                return ctrl.Result{}, err
                        }</span>

                        <span class="cov8" title="1">depNames := []string{}
                        for _, dep := range deploymentsList.Items </span><span class="cov8" title="1">{
                                depNames = append(depNames, dep.Name)
                        }</span>
                        <span class="cov8" title="1">deployments = depNames</span>
                }

                <span class="cov8" title="1">pvcAndPVNamesMap, err := fetchCSIPVCAndPVNames(k8sOps, reqLogger)
                if err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">if len(pvcAndPVNamesMap) == 0 </span><span class="cov8" title="1">{
                        return ctrl.Result{RequeueAfter: constants.ReconcilationTime}, nil
                }</span>
                <span class="cov8" title="1">reqLogger.Info("PVCs using CSI StorageClasses", "pvc:pv-names", pvcAndPVNamesMap)

                pvcNames := maps.Keys(pvcAndPVNamesMap)

                csiApplications, err := fetchDeploymentsUsingCSIVolumes(k8sOps, reqLogger, deployments, pvcNames)
                if err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">reqLogger.Info("Deployments which are using CSI Volumes in given namespace", "namespace", namespace,
                        "applications", csiApplications)

                if len(csiApplications) == 0 </span><span class="cov8" title="1">{
                        reqLogger.Info("No Deployment found in requested namespace")
                        continue</span>
                }

                <span class="cov8" title="1">var csiNodeServerPods = map[string]string{} // {nodeName1: csiNodePod1, nodeName2: csiNodePod2, ...}
                var nodeVolumePodMapping = map[string]map[string][]string{}
                /*
                        {
                                nodeName1: {
                                        vol1: [pod1, pod2],
                                        vol2: [pod1]
                                }
                                nodeName2: {
                                        vol1: [pod3]
                                }
                        }
                */
                var deploymentPods = map[string]corev1.Pod{} // {pod1: corev1.Pod{}, pod2: corev1.Pod}

                // Fetch all Pods in given namespace
                podsList, err := k8sOps.ListPod()
                if err != nil </span><span class="cov8" title="1">{
                        reqLogger.Error(err, "failed to get pods list")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">reqLogger.Info("Successfully fetched pods in given namespace", "namespace", namespace, "number-of-pods",
                        len(podsList.Items))

                for ind, podData := range podsList.Items </span><span class="cov8" title="1">{
                        podName := podData.Name
                        if util.MatchesPrefix(csiApplications, podName) </span><span class="cov8" title="1">{
                                reqLogger.Info("Application Pod found", "name", podName)

                                volumesUsedByPod := podData.Spec.Volumes
                                for _, volume := range volumesUsedByPod </span><span class="cov8" title="1">{
                                        pvcDetails := volume.VolumeSource.PersistentVolumeClaim
                                        if pvcDetails != nil </span><span class="cov8" title="1">{
                                                pvcName := pvcDetails.ClaimName

                                                if util.Contains(pvcNames, pvcName) </span><span class="cov8" title="1">{
                                                        reqLogger.Info("Pod details", "pod-name", podName, "pvc-name", pvcName)
                                                        nodeName := podData.Spec.NodeName
                                                        volumeData, ok := nodeVolumePodMapping[nodeName]
                                                        if !ok </span><span class="cov8" title="1">{
                                                                volumeData = map[string][]string{}
                                                        }</span>

                                                        <span class="cov8" title="1">volumeName := pvcAndPVNamesMap[pvcName]
                                                        podData, ok := volumeData[volumeName]
                                                        if !ok </span><span class="cov8" title="1">{
                                                                podData = []string{}
                                                        }</span>

                                                        <span class="cov8" title="1">if !util.Contains(podData, podName) </span><span class="cov8" title="1">{
                                                                podData = append(podData, podName)
                                                        }</span>

                                                        <span class="cov8" title="1">volumeData[volumeName] = podData
                                                        nodeVolumePodMapping[nodeName] = volumeData

                                                        deploymentPods[podName] = podsList.Items[ind]</span>
                                                }
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">reqLogger.Info("node-names maped with volumes and deployment pods", "nodeVolumeMap", nodeVolumePodMapping)

                // Get Pods in ibm-object-csi-driver-operator ns
                k8sOps.Namespace = constants.CSIOperatorNamespace
                podsInOpNs, err := k8sOps.ListPod()
                if err != nil </span><span class="cov8" title="1">{
                        reqLogger.Error(err, "failed to fetch pods in namespace: "+constants.CSIOperatorNamespace)
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">reqLogger.Info("Successfully fetched pods in namespace", "number-of-pods", len(podsInOpNs.Items))

                for ind := range podsInOpNs.Items </span><span class="cov8" title="1">{
                        pod := podsInOpNs.Items[ind]
                        if strings.HasPrefix(pod.Name, constants.GetResourceName(constants.CSINode)) </span><span class="cov8" title="1">{
                                csiNodeServerPods[pod.Spec.NodeName] = pod.Name
                        }</span>
                }
                <span class="cov8" title="1">reqLogger.Info("node-names maped with csi node-server pods", "csiNodeServerPods", csiNodeServerPods)

                // If CSI Driver Node Pods not found, reconcile
                if len(csiNodeServerPods) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for nodeName, volumesData := range nodeVolumePodMapping </span><span class="cov8" title="1">{
                        // Fetch volume stats from Logs of the Node Server Pod
                        getVolStatsFromLogs, err := fetchVolumeStatsFromNodeServerPodLogs(ctx, csiNodeServerPods[nodeName],
                                constants.CSIOperatorNamespace, logTailLines, r.IsTest)
                        if err != nil </span><span class="cov8" title="1">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">reqLogger.Info("Volume Stats from NodeServer Pod Logs", "volume-stas", getVolStatsFromLogs)

                        for volume, podData := range volumesData </span><span class="cov8" title="1">{
                                getVolStatsFromLogs, ok := getVolStatsFromLogs[volume]
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if strings.Contains(getVolStatsFromLogs, constants.TransportEndpointError) </span><span class="cov8" title="1">{
                                        reqLogger.Info("Stale Volume Found", "volume", volume)

                                        for _, podName := range podData </span><span class="cov8" title="1">{
                                                reqLogger.Info("Pod using stale volume", "volume-name", volume, "pod-name", podName)

                                                pod := deploymentPods[podName]
                                                err = k8sOps.DeletePod(&amp;pod)
                                                if err != nil </span><span class="cov8" title="1">{
                                                        if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                                                                reqLogger.Info("Pod not found.")
                                                                continue</span>
                                                        }
                                                        <span class="cov8" title="1">reqLogger.Error(err, "failed to delete pod")
                                                        return ctrl.Result{}, err</span>
                                                }
                                                <span class="cov8" title="1">reqLogger.Info("Pod deleted.")</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return ctrl.Result{RequeueAfter: constants.ReconcilationTime}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *RecoverStaleVolumeReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;objectdriverv1alpha1.RecoverStaleVolume{}).
                Complete(r)
}</span>

func fetchCSIPVCAndPVNames(k8sOps *crutils.K8sResourceOps, log logr.Logger) (map[string]string, error) <span class="cov8" title="1">{
        defer LogFunctionDuration(log, "fetchCSIPVCAndPVNames", time.Now())

        pvcList, err := k8sOps.ListPVC()
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to get pvc list")
                return nil, err
        }</span>

        <span class="cov8" title="1">reqData := map[string]string{}

        for _, pvc := range pvcList.Items </span><span class="cov8" title="1">{
                log.Info("PVC Found", "pvc-name", pvc.Name, "namespace", pvc.Namespace)

                storageClassName := pvc.Spec.StorageClassName
                if storageClassName == nil </span><span class="cov8" title="1">{
                        log.Info("PVC does not have any storageClass", "pvc-name", pvc.Name)
                        continue</span>
                }

                <span class="cov8" title="1">scName := *storageClassName
                if scName == "" </span><span class="cov8" title="1">{
                        log.Info("PVC does not have any storageClass", "pvc-name", pvc.Name)
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(scName, constants.StorageClassPrefix) </span><span class="cov8" title="1">{
                        reqData[pvc.Name] = pvc.Spec.VolumeName
                }</span>
        }

        <span class="cov8" title="1">return reqData, nil</span>
}

func fetchDeploymentsUsingCSIVolumes(k8sOps *crutils.K8sResourceOps, log logr.Logger, depNames []string,
        reqPVCNames []string) ([]string, error) <span class="cov8" title="1">{
        defer LogFunctionDuration(log, "fetchDeploymentsUsingCSIVolumes", time.Now())

        var reqDeploymentNames []string

        for _, name := range depNames </span><span class="cov8" title="1">{
                deployment, err := k8sOps.GetDeployment(name)
                if err != nil </span><span class="cov8" title="1">{
                        if k8serr.IsNotFound(err) </span><span class="cov8" title="1">{
                                log.Info("Deployment not found.")
                                continue</span>
                        }
                        <span class="cov8" title="1">log.Error(err, "failed to get deployment")
                        return nil, err</span>
                }

                <span class="cov8" title="1">volumes := deployment.Spec.Template.Spec.Volumes
                for _, vol := range volumes </span><span class="cov8" title="1">{
                        pvcDetails := vol.VolumeSource.PersistentVolumeClaim
                        if pvcDetails != nil </span><span class="cov8" title="1">{
                                pvcName := pvcDetails.ClaimName
                                if util.Contains(reqPVCNames, pvcName) </span><span class="cov8" title="1">{
                                        reqDeploymentNames = append(reqDeploymentNames, name)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return reqDeploymentNames, nil</span>
}

func createK8sClient() (*KubernetesClient, error) <span class="cov8" title="1">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;KubernetesClient{
                Clientset: clientset,
        }, nil</span>
}

func fetchVolumeStatsFromNodeServerPodLogs(ctx context.Context, nodeServerPod, namespace string, logTailLines int64,
        isTest bool) (map[string]string, error) <span class="cov8" title="1">{
        defer LogFunctionDuration(staleVolLog, "fetchVolumeStatsFromNodeServerPodLogs", time.Now())

        staleVolLog.Info("Input Parameters: ", "nodeServerPod", nodeServerPod, "namespace", namespace, "isTest", isTest)
        podLogOpts := &amp;corev1.PodLogOptions{
                Container: constants.NodeContainerName,
                TailLines: &amp;logTailLines,
        }

        k8sClient, err := kubeClient()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request := k8sClient.Clientset.CoreV1().Pods(namespace).GetLogs(nodeServerPod, podLogOpts)

        nodePodLogs, err := request.Stream(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer nodePodLogs.Close() // #nosec G307 Close Stream

        buf := new(bytes.Buffer)
        _, err = io.Copy(buf, nodePodLogs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeServerPodLogs := buf.String()

        if isTest </span><span class="cov8" title="1">{
                nodeServerPodLogs = testNodeServerPodLogs
        }</span>

        <span class="cov8" title="1">return parseLogs(nodeServerPodLogs), nil</span>
}

// LogFunctionDuration calculates time taken by a method
func LogFunctionDuration(logger logr.Logger, methodName string, start time.Time) <span class="cov8" title="1">{
        duration := time.Since(start)
        logger.Info("Time to complete", methodName, duration.Seconds())
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package syncer ...
package syncer

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
)

var defaultAnnotations = []string{
        "productID",
        "productName",
        "productVersion",
}

func ensureAnnotations(templateObjectMeta *metav1.ObjectMeta, objectMeta *metav1.ObjectMeta, annotations labels.Set) <span class="cov0" title="0">{
        for _, s := range defaultAnnotations </span><span class="cov0" title="0">{
                templateObjectMeta.Annotations[s] = annotations[s]
                objectMeta.Annotations[s] = annotations[s]
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package syncer ...
package syncer

import (
        "fmt"

        "github.com/imdario/mergo"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/intstr"
        "sigs.k8s.io/controller-runtime/pkg/client"

        objectdriverv1alpha1 "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util"
        "github.com/presslabs/controller-util/pkg/mergo/transformers"
        "github.com/presslabs/controller-util/pkg/syncer"
)

type csiControllerSyncer struct {
        driver *crutils.IBMObjectCSI
        obj    runtime.Object
}

// NewCSIControllerSyncer returns a syncer for CSI controller
func NewCSIControllerSyncer(c client.Client, driver *crutils.IBMObjectCSI) syncer.Interface <span class="cov0" title="0">{
        obj := &amp;appsv1.Deployment{
                ObjectMeta: metav1.ObjectMeta{
                        Name:        constants.GetResourceName(constants.CSIController),
                        Namespace:   driver.Namespace,
                        Annotations: driver.GetAnnotations(),
                        Labels:      driver.GetLabels(),
                },
                Spec: appsv1.DeploymentSpec{
                        Selector: metav1.SetAsLabelSelector(driver.GetCSIControllerSelectorLabels()),
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels:      driver.GetCSIControllerPodLabels(),
                                        Annotations: driver.GetAnnotations(),
                                },
                                Spec: corev1.PodSpec{},
                        },
                        MinReadySeconds: 30,
                },
        }

        sync := &amp;csiControllerSyncer{
                driver: driver,
                obj:    obj,
        }

        return syncer.NewObjectSyncer(constants.CSIController, driver.Unwrap(), obj, c, func() error </span><span class="cov0" title="0">{
                return sync.SyncFn()
        }</span>)
}

func (s *csiControllerSyncer) SyncFn() error <span class="cov0" title="0">{
        out := s.obj.(*appsv1.Deployment)

        out.Spec.Selector = metav1.SetAsLabelSelector(s.driver.GetCSIControllerSelectorLabels())

        controllerLabels := s.driver.GetCSIControllerPodLabels()
        controllerAnnotations := s.driver.GetAnnotations()

        // ensure template
        out.Spec.Template.ObjectMeta.Labels = controllerLabels

        out.ObjectMeta.Labels = controllerLabels
        ensureAnnotations(&amp;out.Spec.Template.ObjectMeta, &amp;out.ObjectMeta, controllerAnnotations)

        err := mergo.Merge(&amp;out.Spec.Template.Spec, s.ensurePodSpec(), mergo.WithTransformers(transformers.PodSpec))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *csiControllerSyncer) ensurePodSpec() corev1.PodSpec <span class="cov0" title="0">{
        return corev1.PodSpec{
                Containers: s.ensureContainersSpec(),
                Volumes:    s.ensureVolumes(),
                SecurityContext: &amp;corev1.PodSecurityContext{
                        RunAsNonRoot: util.True(),
                        RunAsUser:    func(uid int64) *int64 </span><span class="cov0" title="0">{ return &amp;uid }</span>(2121),
                        RunAsGroup:   func(uid int64) *int64 <span class="cov0" title="0">{ return &amp;uid }</span>(2121),
                },
                Affinity:           s.driver.Spec.Controller.Affinity,
                Tolerations:        s.driver.Spec.Controller.Tolerations,
                ServiceAccountName: constants.GetResourceName(constants.CSIControllerServiceAccount),
                PriorityClassName:  constants.CSIControllerPriorityClassName,
        }
}

func (s *csiControllerSyncer) ensureContainersSpec() []corev1.Container <span class="cov0" title="0">{
        controllerPlugin := s.ensureContainer(constants.ControllerContainerName,
                s.driver.GetCSIControllerImage(),
                []string{"--endpoint=$(CSI_ENDPOINT)",
                        "--servermode=controller",
                        "--v=5",
                        "--logtostderr=true",
                },
        )

        controllerPlugin.Resources = getCSIControllerResourceRequests(s.driver)

        healthPort := s.driver.Spec.HealthPort
        if healthPort == 0 </span><span class="cov0" title="0">{
                healthPort = constants.HealthPortNumber
        }</span>

        <span class="cov0" title="0">controllerPlugin.Ports = ensurePorts(corev1.ContainerPort{
                Name:          constants.HealthPortName,
                ContainerPort: int32(healthPort),
        })
        controllerPlugin.ImagePullPolicy = s.driver.Spec.Controller.ImagePullPolicy

        controllerContainerHealthPort := intstr.FromInt(int(healthPort))
        controllerPlugin.LivenessProbe = ensureProbe(10, 100, 5, corev1.ProbeHandler{
                HTTPGet: &amp;corev1.HTTPGetAction{
                        Path:   "/healthz",
                        Port:   controllerContainerHealthPort,
                        Scheme: corev1.URISchemeHTTP,
                },
        })

        provisionerArgs := []string{
                "--csi-address=$(ADDRESS)",
                "--v=5",
                "--timeout=120s",
                "--extra-create-metadata=true",
        }
        provisioner := s.ensureContainer(constants.CSIProvisioner,
                s.getCSIProvisionerImage(),
                provisionerArgs,
        )
        provisioner.ImagePullPolicy = s.getCSIProvisionerPullPolicy()
        provisioner.Resources = getSidecarResourceRequests(s.driver, constants.CSIProvisioner)

        healthPortArg := fmt.Sprintf("--health-port=%v", healthPort)
        livenessProbe := s.ensureContainer(constants.LivenessProbe,
                s.getLivenessProbeImage(),
                []string{
                        "--csi-address=/csi/csi.sock",
                        healthPortArg,
                },
        )
        livenessProbe.ImagePullPolicy = s.getLivenessProbePullPolicy()
        livenessProbe.Resources = getSidecarResourceRequests(s.driver, constants.LivenessProbe)

        return []corev1.Container{
                controllerPlugin,
                provisioner,
                livenessProbe,
        }</span>
}

func (s *csiControllerSyncer) ensureContainer(name, image string, args []string) corev1.Container <span class="cov0" title="0">{
        sc := &amp;corev1.SecurityContext{
                AllowPrivilegeEscalation: util.False(),
        }
        fillSecurityContextCapabilities(sc)
        return corev1.Container{
                Name:            name,
                Image:           image,
                Args:            args,
                Env:             s.getEnvFor(name),
                VolumeMounts:    s.getVolumeMountsFor(name),
                SecurityContext: sc,
        }
}</span>

func (s *csiControllerSyncer) getEnvFor(name string) []corev1.EnvVar <span class="cov0" title="0">{
        switch name </span>{
        case constants.ControllerContainerName:<span class="cov0" title="0">
                return []corev1.EnvVar{
                        {
                                Name:  "CSI_ENDPOINT",
                                Value: constants.CSIEndpoint,
                        },
                }</span>

        case constants.CSIProvisioner:<span class="cov0" title="0">
                return []corev1.EnvVar{
                        {
                                Name:  "ADDRESS",
                                Value: constants.ControllerSocketPath,
                        },
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *csiControllerSyncer) getVolumeMountsFor(name string) []corev1.VolumeMount <span class="cov0" title="0">{
        switch name </span>{
        case constants.ControllerContainerName, constants.CSIProvisioner:<span class="cov0" title="0">
                return []corev1.VolumeMount{
                        {
                                Name:      constants.SocketVolumeName,
                                MountPath: constants.ControllerSocketVolumeMountPath,
                        },
                }</span>

        case constants.LivenessProbe:<span class="cov0" title="0">
                return []corev1.VolumeMount{
                        {
                                Name:      constants.SocketVolumeName,
                                MountPath: constants.ControllerLivenessProbeContainerSocketVolumeMountPath,
                        },
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *csiControllerSyncer) ensureVolumes() []corev1.Volume <span class="cov0" title="0">{
        return []corev1.Volume{
                ensureVolume(constants.SocketVolumeName, corev1.VolumeSource{
                        EmptyDir: &amp;corev1.EmptyDirVolumeSource{},
                }),
        }
}</span>

func (s *csiControllerSyncer) getSidecarByName(name string) *objectdriverv1alpha1.CSISidecar <span class="cov0" title="0">{
        return getSidecarByName(s.driver, name)
}</span>

func (s *csiControllerSyncer) getSidecarImageByName(name string) string <span class="cov0" title="0">{
        sidecar := s.getSidecarByName(name)
        if sidecar != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%s", sidecar.Repository, sidecar.Tag)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (s *csiControllerSyncer) getCSIProvisionerImage() string <span class="cov0" title="0">{
        return s.getSidecarImageByName(constants.CSIProvisioner)
}</span>

func (s *csiControllerSyncer) getLivenessProbeImage() string <span class="cov0" title="0">{
        return s.getSidecarImageByName(constants.LivenessProbe)
}</span>

func (s *csiControllerSyncer) getSidecarPullPolicy(sidecarName string) corev1.PullPolicy <span class="cov0" title="0">{
        sidecar := s.getSidecarByName(sidecarName)
        if sidecar != nil &amp;&amp; sidecar.ImagePullPolicy != "" </span><span class="cov0" title="0">{
                return sidecar.ImagePullPolicy
        }</span>
        <span class="cov0" title="0">return corev1.PullIfNotPresent</span>
}

func (s *csiControllerSyncer) getCSIProvisionerPullPolicy() corev1.PullPolicy <span class="cov0" title="0">{
        return s.getSidecarPullPolicy(constants.CSIProvisioner)
}</span>

func (s *csiControllerSyncer) getLivenessProbePullPolicy() corev1.PullPolicy <span class="cov0" title="0">{
        return s.getSidecarPullPolicy(constants.LivenessProbe)
}</span>

func ensurePorts(ports ...corev1.ContainerPort) []corev1.ContainerPort <span class="cov0" title="0">{
        return ports
}</span>

func ensureProbe(delay, timeout, period int32, handler corev1.ProbeHandler) *corev1.Probe <span class="cov0" title="0">{
        return &amp;corev1.Probe{
                InitialDelaySeconds: delay,
                TimeoutSeconds:      timeout,
                PeriodSeconds:       period,
                ProbeHandler:        handler,
                SuccessThreshold:    1,
                FailureThreshold:    30,
        }
}</span>

func ensureVolume(name string, source corev1.VolumeSource) corev1.Volume <span class="cov0" title="0">{
        return corev1.Volume{
                Name:         name,
                VolumeSource: source,
        }
}</span>

func getSidecarByName(driver *crutils.IBMObjectCSI, name string) *objectdriverv1alpha1.CSISidecar <span class="cov0" title="0">{
        for _, sidecar := range driver.Spec.Sidecars </span><span class="cov0" title="0">{
                if sidecar.Name == name </span><span class="cov0" title="0">{
                        return &amp;sidecar
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getCSIControllerResourceRequests(driver *crutils.IBMObjectCSI) corev1.ResourceRequirements <span class="cov0" title="0">{
        resources := driver.GetCSIControllerResourceRequests()

        var requests, limits corev1.ResourceList

        if resources.Requests.CPU != "" &amp;&amp; resources.Requests.Memory != "" </span><span class="cov0" title="0">{
                requests = corev1.ResourceList{
                        corev1.ResourceCPU:    resource.MustParse(resources.Requests.CPU),
                        corev1.ResourceMemory: resource.MustParse(resources.Requests.Memory),
                }
        }</span>
        <span class="cov0" title="0">if resources.Limits.CPU != "" &amp;&amp; resources.Limits.Memory != "" </span><span class="cov0" title="0">{
                limits = corev1.ResourceList{
                        corev1.ResourceCPU:    resource.MustParse(resources.Limits.CPU),
                        corev1.ResourceMemory: resource.MustParse(resources.Limits.Memory),
                }
        }</span>
        <span class="cov0" title="0">return corev1.ResourceRequirements{
                Limits:   limits,
                Requests: requests,
        }</span>
}

func getSidecarResourceRequests(driver *crutils.IBMObjectCSI, sidecarName string) corev1.ResourceRequirements <span class="cov0" title="0">{
        sidecar := getSidecarByName(driver, sidecarName)

        sidecarResources := corev1.ResourceRequirements{}

        if sidecar != nil </span><span class="cov0" title="0">{
                resources := sidecar.Resources

                var requests, limits corev1.ResourceList

                if resources.Requests.CPU != "" &amp;&amp; resources.Requests.Memory != "" </span><span class="cov0" title="0">{
                        requests = corev1.ResourceList{
                                corev1.ResourceCPU:    resource.MustParse(resources.Requests.CPU),
                                corev1.ResourceMemory: resource.MustParse(resources.Requests.Memory),
                        }
                }</span>
                <span class="cov0" title="0">if resources.Limits.CPU != "" &amp;&amp; resources.Limits.Memory != "" </span><span class="cov0" title="0">{
                        limits = corev1.ResourceList{
                                corev1.ResourceCPU:    resource.MustParse(resources.Limits.CPU),
                                corev1.ResourceMemory: resource.MustParse(resources.Limits.Memory),
                        }
                }</span>

                <span class="cov0" title="0">sidecarResources.Limits = limits
                sidecarResources.Requests = requests</span>
        }

        <span class="cov0" title="0">return sidecarResources</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package syncer ..
package syncer

import (
        "fmt"

        "github.com/imdario/mergo"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/intstr"
        "sigs.k8s.io/controller-runtime/pkg/client"

        objectdriverv1alpha1 "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util"
        "github.com/presslabs/controller-util/pkg/mergo/transformers"
        "github.com/presslabs/controller-util/pkg/syncer"
)

type csiNodeSyncer struct {
        driver *crutils.IBMObjectCSI
        obj    runtime.Object
}

// NewCSINodeSyncer returns a syncer for CSI node
func NewCSINodeSyncer(c client.Client, driver *crutils.IBMObjectCSI) syncer.Interface <span class="cov0" title="0">{
        obj := &amp;appsv1.DaemonSet{
                ObjectMeta: metav1.ObjectMeta{
                        Name:        constants.GetResourceName(constants.CSINode),
                        Namespace:   driver.Namespace,
                        Annotations: driver.GetAnnotations(),
                        Labels:      driver.GetLabels(),
                },
                Spec: appsv1.DaemonSetSpec{
                        Selector: metav1.SetAsLabelSelector(driver.GetCSINodeSelectorLabels()),
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels:      driver.GetCSINodePodLabels(),
                                        Annotations: driver.GetAnnotations(),
                                },
                                Spec: corev1.PodSpec{},
                        },
                        MinReadySeconds: 30,
                        UpdateStrategy: appsv1.DaemonSetUpdateStrategy{
                                Type: appsv1.RollingUpdateDaemonSetStrategyType,
                                RollingUpdate: &amp;appsv1.RollingUpdateDaemonSet{
                                        MaxUnavailable: func(i intstr.IntOrString) *intstr.IntOrString </span><span class="cov0" title="0">{ return &amp;i }</span>(intstr.FromString("10%")),
                                },
                        },
                },
        }

        <span class="cov0" title="0">sync := &amp;csiNodeSyncer{
                driver: driver,
                obj:    obj,
        }

        return syncer.NewObjectSyncer(constants.CSINode, driver.Unwrap(), obj, c, func() error </span><span class="cov0" title="0">{
                return sync.SyncFn()
        }</span>)
}

func (s *csiNodeSyncer) SyncFn() error <span class="cov0" title="0">{
        out := s.obj.(*appsv1.DaemonSet)

        out.Spec.Selector = metav1.SetAsLabelSelector(s.driver.GetCSINodeSelectorLabels())

        nodeLabels := s.driver.GetCSINodePodLabels()

        // ensure template
        out.Spec.Template.ObjectMeta.Labels = nodeLabels
        out.ObjectMeta.Labels = nodeLabels
        nodeAnnotations := s.driver.GetAnnotations()

        ensureAnnotations(&amp;out.Spec.Template.ObjectMeta, &amp;out.ObjectMeta, nodeAnnotations)

        err := mergo.Merge(&amp;out.Spec.Template.Spec, s.ensurePodSpec(), mergo.WithTransformers(transformers.PodSpec))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *csiNodeSyncer) ensurePodSpec() corev1.PodSpec <span class="cov0" title="0">{
        return corev1.PodSpec{
                Containers: s.ensureContainersSpec(),
                Volumes:    s.ensureVolumes(),
                SecurityContext: &amp;corev1.PodSecurityContext{
                        RunAsNonRoot: util.True(),
                        RunAsUser:    func(uid int64) *int64 </span><span class="cov0" title="0">{ return &amp;uid }</span>(2121),
                        RunAsGroup:   func(uid int64) *int64 <span class="cov0" title="0">{ return &amp;uid }</span>(2121),
                },
                Affinity:           s.driver.Spec.Node.Affinity,
                Tolerations:        s.driver.Spec.Node.Tolerations,
                ServiceAccountName: constants.GetResourceName(constants.CSINodeServiceAccount),
                PriorityClassName:  constants.CSINodePriorityClassName,
        }
}

func (s *csiNodeSyncer) ensureContainersSpec() []corev1.Container <span class="cov0" title="0">{
        // node plugin container
        nodePlugin := s.ensureContainer(constants.NodeContainerName,
                s.driver.GetCSINodeImage(),
                []string{
                        "--servermode=node",
                        "--endpoint=$(CSI_ENDPOINT)",
                        "--nodeid=$(KUBE_NODE_NAME)",
                        "--logtostderr=true",
                        "--v=5",
                },
        )

        nodePlugin.Resources = getCSINodeResourceRequests(s.driver)

        nodePlugin.Ports = ensurePorts(corev1.ContainerPort{
                Name:          constants.CosCsiMounterHealthPortName,
                ContainerPort: int32(constants.CosCsiMounterHealthPortNumber),
        })

        nodePlugin.ImagePullPolicy = s.driver.Spec.Node.ImagePullPolicy

        nodePlugin.LivenessProbe = ensureProbe(10, 3, 10, corev1.ProbeHandler{
                HTTPGet: &amp;corev1.HTTPGetAction{
                        Path:   "/cos-csi-mounter/socket-health",
                        Port:   intstr.FromInt(int(constants.CosCsiMounterHealthPortNumber)),
                        Scheme: corev1.URISchemeHTTP,
                },
        })

        nodePlugin.SecurityContext = &amp;corev1.SecurityContext{
                RunAsNonRoot: util.False(),
                Privileged:   util.True(), // Revisit if node server needs privileged permission
                RunAsUser:    func(uid int64) *int64 </span><span class="cov0" title="0">{ return &amp;uid }</span>(0),
                RunAsGroup:   func(uid int64) *int64 <span class="cov0" title="0">{ return &amp;uid }</span>(0),
        }
        <span class="cov0" title="0">fillSecurityContextCapabilities(
                nodePlugin.SecurityContext,
        )

        // node driver registrar sidecar
        registrar := s.ensureContainer(constants.CSINodeDriverRegistrar,
                s.getCSINodeDriverRegistrarImage(),
                []string{
                        "--csi-address=$(ADDRESS)",
                        "--kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)",
                        "--v=5",
                },
        )
        registrar.SecurityContext = &amp;corev1.SecurityContext{
                RunAsNonRoot: util.False(),
                RunAsUser:    func(uid int64) *int64 </span><span class="cov0" title="0">{ return &amp;uid }</span>(0),
                RunAsGroup:   func(uid int64) *int64 <span class="cov0" title="0">{ return &amp;uid }</span>(0),
                Privileged:   util.False(),
        }
        <span class="cov0" title="0">fillSecurityContextCapabilities(registrar.SecurityContext)
        registrar.ImagePullPolicy = s.getCSINodeDriverRegistrarPullPolicy()
        registrar.Resources = getSidecarResourceRequests(s.driver, constants.CSINodeDriverRegistrar)

        healthPort := s.driver.Spec.HealthPort
        if healthPort == 0 </span><span class="cov0" title="0">{
                healthPort = constants.HealthPortNumber
        }</span>

        // liveness probe sidecar
        <span class="cov0" title="0">healthPortArg := fmt.Sprintf("--health-port=%v", healthPort)
        livenessProbe := s.ensureContainer(constants.LivenessProbe,
                s.getLivenessProbeImage(),
                []string{
                        "--csi-address=/csi/csi.sock",
                        healthPortArg,
                },
        )

        livenessProbe.SecurityContext = &amp;corev1.SecurityContext{
                RunAsNonRoot: util.True(),
                RunAsUser:    func(uid int64) *int64 </span><span class="cov0" title="0">{ return &amp;uid }</span>(2121),
                RunAsGroup:   func(uid int64) *int64 <span class="cov0" title="0">{ return &amp;uid }</span>(2121),
                Privileged:   util.False(),
                // This is intended to help the container access privileged host paths like csi socket
                SELinuxOptions: &amp;corev1.SELinuxOptions{
                        Type:  "spc_t", // "Super Privileged Container" type.
                        Level: "s0",    // security level.
                },
        }

        <span class="cov0" title="0">livenessProbe.Ports = ensurePorts(corev1.ContainerPort{
                Name:          constants.HealthPortName,
                ContainerPort: int32(healthPort),
        })

        livenessProbe.LivenessProbe = ensureProbe(10, 3, 10, corev1.ProbeHandler{
                HTTPGet: &amp;corev1.HTTPGetAction{
                        Path:   "/healthz",
                        Port:   intstr.FromInt(int(healthPort)),
                        Scheme: corev1.URISchemeHTTP,
                },
        })

        fillSecurityContextCapabilities(livenessProbe.SecurityContext)
        livenessProbe.ImagePullPolicy = s.getCSINodeDriverRegistrarPullPolicy()
        livenessProbe.Resources = getSidecarResourceRequests(s.driver, constants.LivenessProbe)

        return []corev1.Container{
                nodePlugin,
                registrar,
                livenessProbe,
        }</span>
}

func (s *csiNodeSyncer) ensureContainer(name, image string, args []string) corev1.Container <span class="cov0" title="0">{
        return corev1.Container{
                Name:         name,
                Image:        image,
                Args:         args,
                Env:          s.getEnvFor(name),
                VolumeMounts: s.getVolumeMountsFor(name),
        }
}</span>

func envVarFromField(name, fieldPath string) corev1.EnvVar <span class="cov0" title="0">{
        env := corev1.EnvVar{
                Name: name,
                ValueFrom: &amp;corev1.EnvVarSource{
                        FieldRef: &amp;corev1.ObjectFieldSelector{
                                APIVersion: constants.APIVersion,
                                FieldPath:  fieldPath,
                        },
                },
        }
        return env
}</span>

func (s *csiNodeSyncer) getEnvFor(name string) []corev1.EnvVar <span class="cov0" title="0">{
        switch name </span>{
        case constants.NodeContainerName:<span class="cov0" title="0">
                envVars := []corev1.EnvVar{
                        {
                                Name:  "CSI_ENDPOINT",
                                Value: constants.CSINodeEndpoint,
                        },
                        {
                                Name:  "COS_CSI_MOUNTER_SOCKET",
                                Value: constants.COSCSIMounterSocketPath,
                        },
                        envVarFromField("KUBE_NODE_NAME", "spec.nodeName"),
                        {
                                Name:  "IS_NODE_SERVER",
                                Value: "true",
                        },
                        {
                                Name:  "SIDECAR_GROUP_ID",
                                Value: "2121",
                        },
                }
                if s.driver.Spec.Node.MaxVolumesPerNode != "" </span><span class="cov0" title="0">{
                        envVars = append(envVars, corev1.EnvVar{
                                Name:  constants.MaxVolumesPerNodeEnv,
                                Value: s.driver.Spec.Node.MaxVolumesPerNode,
                        })
                }</span>
                <span class="cov0" title="0">return envVars</span>

        case constants.CSINodeDriverRegistrar:<span class="cov0" title="0">
                return []corev1.EnvVar{
                        {
                                Name:  "ADDRESS",
                                Value: constants.NodeSocketPath,
                        },
                        {
                                Name:  "DRIVER_REG_SOCK_PATH",
                                Value: constants.NodeRegistrarSocketPath,
                        },
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *csiNodeSyncer) getVolumeMountsFor(name string) []corev1.VolumeMount <span class="cov0" title="0">{
        mountPropagationB := corev1.MountPropagationBidirectional

        switch name </span>{
        case constants.NodeContainerName:<span class="cov0" title="0">
                return []corev1.VolumeMount{
                        {
                                Name:      constants.PluginVolumeName,
                                MountPath: constants.NodeSocketVolumeMountPath,
                        },
                        {
                                Name:             "kubelet-dir",
                                MountPath:        "/var/lib/kubelet",
                                MountPropagation: &amp;mountPropagationB,
                        },
                        {
                                Name:             "kubelet-dir-ibm",
                                MountPath:        "/var/data/kubelet",
                                MountPropagation: &amp;mountPropagationB,
                        },
                        {
                                Name:             "coscsi-socket-path",
                                MountPath:        "/var/lib/coscsi-sock",
                                MountPropagation: &amp;mountPropagationB,
                        },
                        {
                                Name:      "coscsi-mounter-config-path",
                                MountPath: "/var/lib/coscsi-config",
                        },
                }</span>

        case constants.CSINodeDriverRegistrar:<span class="cov0" title="0">
                return []corev1.VolumeMount{
                        {
                                Name:      constants.PluginVolumeName,
                                MountPath: constants.NodeSocketVolumeMountPath,
                        },
                        {
                                Name:      constants.RegistrationVolumeName,
                                MountPath: constants.RegistrationVolumeMountPath,
                        },
                }</span>

        case constants.LivenessProbe:<span class="cov0" title="0">
                return []corev1.VolumeMount{
                        {
                                Name:      constants.PluginVolumeName,
                                MountPath: constants.NodeSocketVolumeMountPath,
                        },
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *csiNodeSyncer) ensureVolumes() []corev1.Volume <span class="cov0" title="0">{
        return []corev1.Volume{
                ensureVolume("kubelet-dir", ensureHostPathVolumeSource("/var/lib/kubelet", "Directory")),
                ensureVolume("plugin-dir", ensureHostPathVolumeSource("/var/lib/kubelet/plugins/cos.s3.csi.ibm.io", "DirectoryOrCreate")),
                ensureVolume("registration-dir", ensureHostPathVolumeSource("/var/lib/kubelet/plugins_registry", "Directory")),
                ensureVolume("kubelet-dir-ibm", ensureHostPathVolumeSource("/var/data/kubelet", "DirectoryOrCreate")),
                ensureVolume("coscsi-socket-path", ensureHostPathVolumeSource("/var/lib/coscsi-sock", "Directory")),
                ensureVolume("coscsi-mounter-config-path", ensureHostPathVolumeSource("/var/lib/coscsi-config", "DirectoryOrCreate")),
        }
}</span>

func (s *csiNodeSyncer) getSidecarByName(name string) *objectdriverv1alpha1.CSISidecar <span class="cov0" title="0">{
        return getSidecarByName(s.driver, name)
}</span>

func (s *csiNodeSyncer) getCSINodeDriverRegistrarImage() string <span class="cov0" title="0">{
        sidecar := s.getSidecarByName(constants.CSINodeDriverRegistrar)
        if sidecar != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%s", sidecar.Repository, sidecar.Tag)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (s *csiNodeSyncer) getLivenessProbeImage() string <span class="cov0" title="0">{
        sidecar := s.getSidecarByName(constants.LivenessProbe)
        if sidecar != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%s", sidecar.Repository, sidecar.Tag)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (s *csiNodeSyncer) getCSINodeDriverRegistrarPullPolicy() corev1.PullPolicy <span class="cov0" title="0">{
        sidecar := s.getSidecarByName(constants.CSINodeDriverRegistrar)
        if sidecar != nil &amp;&amp; sidecar.ImagePullPolicy != "" </span><span class="cov0" title="0">{
                return sidecar.ImagePullPolicy
        }</span>
        <span class="cov0" title="0">return corev1.PullIfNotPresent</span>
}

func ensureHostPathVolumeSource(path, pathType string) corev1.VolumeSource <span class="cov0" title="0">{
        t := corev1.HostPathType(pathType)

        return corev1.VolumeSource{
                HostPath: &amp;corev1.HostPathVolumeSource{
                        Path: path,
                        Type: &amp;t,
                },
        }
}</span>

func fillSecurityContextCapabilities(sc *corev1.SecurityContext, add ...string) <span class="cov0" title="0">{
        if sc == nil </span><span class="cov0" title="0">{
                sc = &amp;corev1.SecurityContext{}
        }</span>
        <span class="cov0" title="0">sc.Capabilities = &amp;corev1.Capabilities{
                Drop: []corev1.Capability{"ALL"},
        }

        if len(add) &gt; 0 </span><span class="cov0" title="0">{
                adds := []corev1.Capability{}
                for _, a := range add </span><span class="cov0" title="0">{
                        adds = append(adds, corev1.Capability(a))
                }</span>
                <span class="cov0" title="0">sc.Capabilities.Add = adds</span>
        }
}

func getCSINodeResourceRequests(driver *crutils.IBMObjectCSI) corev1.ResourceRequirements <span class="cov0" title="0">{
        resources := driver.GetCSINodeResourceRequests()

        var requests, limits corev1.ResourceList

        if resources.Requests.CPU != "" &amp;&amp; resources.Requests.Memory != "" </span><span class="cov0" title="0">{
                requests = corev1.ResourceList{
                        corev1.ResourceCPU:    resource.MustParse(resources.Requests.CPU),
                        corev1.ResourceMemory: resource.MustParse(resources.Requests.Memory),
                }
        }</span>
        <span class="cov0" title="0">if resources.Limits.CPU != "" &amp;&amp; resources.Limits.Memory != "" </span><span class="cov0" title="0">{
                limits = corev1.ResourceList{
                        corev1.ResourceCPU:    resource.MustParse(resources.Limits.CPU),
                        corev1.ResourceMemory: resource.MustParse(resources.Limits.Memory),
                }
        }</span>

        <span class="cov0" title="0">return corev1.ResourceRequirements{
                Limits:   limits,
                Requests: requests,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package controllers ...
package controllers

import (
        "context"

        "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes/scheme"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

const (
        // CreateError ...
        CreateError = "failed to create"
        // DeleteError ...
        DeleteError = "failed to delete"
        // GetError ...
        GetError = "failed to get"
        // ListError ...
        ListError = "failed to list"
        // UpdateError ...
        UpdateError = "failed to update"
        // NotFoundError ...
        NotFoundError = "not found"
)

var (
        TestLog       = log.Log.WithName("test")
        TestCtx       = context.TODO()
        TestNamespace = "test-namespace"

        currentTime = metav1.Now()

        ibmObjectCSICRName    = "test-csi-cr"
        ibmObjectCSIfinalizer = "ibmobjectcsi.objectdriver.csi.ibm.com/finalizer"

        recoverStaleVolCRName   = "test-vol-cr"
        testDeploymentName      = "test-deployment"
        testDeploymentNamespace = "default"
        testPVName1             = "test-pv-1"
        testPVCName1            = "test-pvc-1"
        testStorageClassName    = constants.StorageClassPrefix + "test"
        testNode1               = "test-node-1"
        testNode2               = "test-node-2"
        testNode3               = "test-node-3"
)

var testNodeServerPodLogs = `E0319 05:32:00.429871       1 nodeserver.go:245] NodeGetVolumeStats: error occurred while getting volume stats map[Error:transport endpoint is not connected VolumeId:test-pv-1]`

func setupScheme() *runtime.Scheme <span class="cov8" title="1">{
        s := scheme.Scheme
        _ = v1alpha1.AddToScheme(s) // #nosec G104: Skip error
        return s
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package util ...
package util

// True returns a *bool whose underlying value is true.
func True() *bool <span class="cov0" title="0">{
        t := true
        return &amp;t
}</span>

// False returns a *bool whose underlying value is false.
func False() *bool <span class="cov0" title="0">{
        t := false
        return &amp;t
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package common ...
package common

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/internal/crutils"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util"
        "github.com/go-logr/logr"
        openshiftclient "github.com/openshift/client-go/config/clientset/versioned"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        storagev1 "k8s.io/api/storage/v1"
        k8sErr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// ControllerHelper ...
type ControllerHelper struct {
        client.Client
        Log              logr.Logger
        Region           string
        CosEP            string // Regional COS Endpoint
        IaaSProvider     string
        S3Provider       string // IBM COS / AWS S3 / Wasabi
        S3ProviderRegion string
}

// NewControllerHelper ...
func NewControllerHelper(client client.Client, logger logr.Logger) *ControllerHelper <span class="cov0" title="0">{
        return &amp;ControllerHelper{
                Client: client,
                Log:    logger,
        }
}</span>

// DeleteClusterRoleBindings ...
func (ch *ControllerHelper) DeleteClusterRoleBindings(clusterRoleBindings []*rbacv1.ClusterRoleBinding) error <span class="cov0" title="0">{
        logger := ch.Log.WithName("DeleteClusterRoleBindings")
        for _, crb := range clusterRoleBindings </span><span class="cov0" title="0">{
                found, err := ch.getClusterRoleBinding(crb)
                if err != nil &amp;&amp; k8sErr.IsNotFound(err) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to get ClusterRoleBinding", "Name", crb.GetName())
                        return err
                }</span>

                <span class="cov0" title="0">logger.Info("deleting ClusterRoleBinding", "Name", crb.GetName())
                if err := ch.Delete(context.TODO(), found); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to delete ClusterRoleBinding", "Name", crb.GetName())
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DeleteStorageClasses ...
func (ch *ControllerHelper) DeleteStorageClasses(storageClasses []*storagev1.StorageClass) error <span class="cov0" title="0">{
        logger := ch.Log.WithName("DeleteStorageClasses")
        for _, sc := range storageClasses </span><span class="cov0" title="0">{
                found, err := ch.getStorageClass(sc)
                if err != nil &amp;&amp; k8sErr.IsNotFound(err) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to get StorageClasses", "Name", sc.GetName())
                        return err
                }</span>
                <span class="cov0" title="0">logger.Info("deleting StorageClasses", "Name", sc.GetName())
                if err := ch.Delete(context.TODO(), found); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to delete StorageClasses", "Name", sc.GetName())
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReconcileClusterRoleBinding ...
func (ch *ControllerHelper) ReconcileClusterRoleBinding(clusterRoleBindings []*rbacv1.ClusterRoleBinding) error <span class="cov0" title="0">{
        logger := ch.Log.WithValues("Resource Type", "ClusterRoleBinding")
        for _, crb := range clusterRoleBindings </span><span class="cov0" title="0">{
                _, err := ch.getClusterRoleBinding(crb)
                if err != nil &amp;&amp; k8sErr.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Info("Creating a new ClusterRoleBinding", "Name", crb.GetName())
                        err = ch.Create(context.TODO(), crb)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed to get ClusterRoleBinding", "Name", crb.GetName())
                        return err
                }</span>
                <span class="cov0" title="0">ch.Log.Info("Skip reconcile: ClusterRoleBinding already exists", "Name", crb.GetName())</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReconcileStorageClasses ...
func (ch *ControllerHelper) ReconcileStorageClasses(storageclasses []*storagev1.StorageClass) error <span class="cov0" title="0">{
        logger := ch.Log.WithValues("Resource Type", "StorageClasses")
        for _, sc := range storageclasses </span><span class="cov0" title="0">{
                k8sSC, err := ch.getStorageClass(sc)
                if err != nil </span><span class="cov0" title="0">{
                        if k8sErr.IsNotFound(err) </span><span class="cov0" title="0">{
                                logger.Info("Creating a new StorageClass", "Name", sc.GetName())
                                err = ch.Create(context.TODO(), sc)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                logger.Error(err, "Failed to get StorageClass", "Name", sc.GetName())
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        patch := client.MergeFrom(k8sSC.DeepCopy())
                        //Apply SC MountOptions related changes only to existing storageclasses, if applicable
                        k8sSC.MountOptions = sc.MountOptions
                        err = ch.Patch(context.TODO(), k8sSC, patch)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "Failed to patch StorageClass", "Name", k8sSC.GetName())
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Info("Reconciled StorageClass", "Name", sc.GetName())</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ch *ControllerHelper) getClusterRoleBinding(crb *rbacv1.ClusterRoleBinding) (*rbacv1.ClusterRoleBinding, error) <span class="cov0" title="0">{
        found := &amp;rbacv1.ClusterRoleBinding{}
        err := ch.Get(context.TODO(), types.NamespacedName{
                Name:      crb.Name,
                Namespace: crb.Namespace,
        }, found)
        return found, err
}</span>

func (ch *ControllerHelper) getStorageClass(sc *storagev1.StorageClass) (*storagev1.StorageClass, error) <span class="cov0" title="0">{
        found := &amp;storagev1.StorageClass{}
        err := ch.Get(context.TODO(), types.NamespacedName{
                Name:      sc.Name,
                Namespace: sc.Namespace,
        }, found)
        return found, err
}</span>

// DeleteClusterRoles ...
func (ch *ControllerHelper) DeleteClusterRoles(clusterRoles []*rbacv1.ClusterRole) error <span class="cov0" title="0">{
        logger := ch.Log.WithName("DeleteClusterRoles")
        for _, cr := range clusterRoles </span><span class="cov0" title="0">{
                found, err := ch.getClusterRole(cr)
                if err != nil &amp;&amp; k8sErr.IsNotFound(err) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to get ClusterRole", "Name", cr.GetName())
                        return err
                }</span>
                <span class="cov0" title="0">logger.Info("deleting ClusterRole", "Name", cr.GetName())
                if err := ch.Delete(context.TODO(), found); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to delete ClusterRole", "Name", cr.GetName())
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReconcileClusterRole ...
func (ch *ControllerHelper) ReconcileClusterRole(clusterRoles []*rbacv1.ClusterRole) error <span class="cov0" title="0">{
        logger := ch.Log.WithValues("Resource Type", "ClusterRole")
        for _, cr := range clusterRoles </span><span class="cov0" title="0">{
                k8sCR, err := ch.getClusterRole(cr)
                if err != nil &amp;&amp; k8sErr.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Info("Creating a new ClusterRole", "Name", cr.GetName())
                        err = ch.Create(context.TODO(), cr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed to get ClusterRole", "Name", cr.GetName())
                        return err
                }</span> else<span class="cov0" title="0"> {
                        patch := client.MergeFrom(k8sCR.DeepCopy())
                        k8sCR.Rules = cr.Rules
                        err = ch.Patch(context.TODO(), k8sCR, patch)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "Failed to patch ClusterRole", "Name", k8sCR.GetName())
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ch *ControllerHelper) getClusterRole(cr *rbacv1.ClusterRole) (*rbacv1.ClusterRole, error) <span class="cov0" title="0">{
        found := &amp;rbacv1.ClusterRole{}
        err := ch.Get(context.TODO(), types.NamespacedName{
                Name:      cr.GetName(),
                Namespace: cr.GetNamespace(),
        }, found)
        return found, err
}</span>

// AddFinalizerIfNotPresent ...
func (ch *ControllerHelper) AddFinalizerIfNotPresent(instance crutils.Instance,
        unwrappedInstance client.Object) error <span class="cov0" title="0">{
        logger := ch.Log.WithName("AddFinalizerIfNotPresent")

        accessor, finalizerName, err := ch.getAccessorAndFinalizerName(instance, unwrappedInstance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ch.updateControllerFinalizer(context.TODO(), constants.AddFinalizer, finalizerName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !util.Contains(accessor.GetFinalizers(), finalizerName) </span><span class="cov0" title="0">{
                logger.Info("adding finalizer to CR", "CR name", accessor.GetName(), "finalizer", finalizerName)
                accessor.SetFinalizers(append(accessor.GetFinalizers(), finalizerName))

                if err := ch.Update(context.TODO(), unwrappedInstance); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to add finalizer to CR", "CR name", accessor.GetName(), "finalizer", finalizerName)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Info("finalizer added to CR", "CR name", accessor.GetName(), "finalizer", finalizerName)</span>
        } else<span class="cov0" title="0"> {
                logger.Info("finalizer already present on CR. Ignoring...", "CR name", accessor.GetName(), "finalizer", finalizerName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RemoveFinalizer ...
func (ch *ControllerHelper) RemoveFinalizer(instance crutils.Instance,
        unwrappedInstance client.Object) error <span class="cov0" title="0">{
        logger := ch.Log.WithName("RemoveFinalizer")

        accessor, finalizerName, err := ch.getAccessorAndFinalizerName(instance, unwrappedInstance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !util.Contains(accessor.GetFinalizers(), finalizerName) </span><span class="cov0" title="0">{
                logger.Info("finalizer already removed from CR. Ignoring...", "CR name", accessor.GetName(), "finalizer", finalizerName)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("removing finalizer from CR", "CR name", accessor.GetName(), "finalizer", finalizerName)
                accessor.SetFinalizers(util.Remove(accessor.GetFinalizers(), finalizerName))

                // Remove old finalizer for backward compatibility, if present
                oldFinalizer := "ibmobjectcsi.objectdriver.csi.ibm.com"
                accessor.SetFinalizers(util.Remove(accessor.GetFinalizers(), oldFinalizer))

                if err := ch.Update(context.TODO(), unwrappedInstance); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to remove finalizer from CR", "CR name", accessor.GetName(), "finalizer", finalizerName)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Info("finalizer removed from CR", "CR name", accessor.GetName(), "finalizer", finalizerName)</span>
        }

        <span class="cov0" title="0">err = ch.updateControllerFinalizer(context.TODO(), constants.RemoveFinalizer, finalizerName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ch *ControllerHelper) getAccessorAndFinalizerName(instance crutils.Instance, unwrappedInstance client.Object) (metav1.Object, string, error) <span class="cov0" title="0">{
        logger := ch.Log.WithName("getAccessorAndFinalizerName")

        gvk, err := apiutil.GVKForObject(unwrappedInstance, ch.Scheme())
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "failed to get group version kink information of instance")
                return nil, "", err
        }</span>
        <span class="cov0" title="0">finalizerName := fmt.Sprintf("%s.%s/finalizer", strings.ToLower(gvk.Kind), constants.APIGroup)

        accessor, err := meta.Accessor(instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "failed to get meta information of instance")
                return nil, "", err
        }</span>
        <span class="cov0" title="0">return accessor, finalizerName, nil</span>
}

// Check the platform, if IBMCloud then get Region and IaaS provider
// If not IBMCloud, check if it is unmanaged/IPI cluster
func (ch *ControllerHelper) GetClusterInfo(inConfig rest.Config) error <span class="cov0" title="0">{
        logger := ch.Log.WithName("getClusterInfo")
        logger.Info("Checking cluster platform...")
        var listOptions = &amp;client.ListOptions{}
        var err error
        nodes := corev1.NodeList{}

        k8sClient, err := kubernetes.NewForConfig(&amp;inConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Unable to load cluster config")
                return err
        }</span>

        <span class="cov0" title="0">if k8sClient != nil </span><span class="cov0" title="0">{
                var list *corev1.NodeList
                list, err = k8sClient.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
                if err == nil </span><span class="cov0" title="0">{
                        nodes = *list
                }</span>
        } else<span class="cov0" title="0"> {
                err = ch.List(context.TODO(), &amp;nodes, listOptions)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Get Cluster Info")
                return err
        }</span>

        <span class="cov0" title="0">if len(nodes.Items) == 0 </span><span class="cov0" title="0">{
                err := errors.New("cluster nodes not found")
                logger.Error(err, "failed to fetch cluster nodes list")
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("Get IBM cluster region...")
        if val, ok := nodes.Items[0].Labels["ibm-cloud.kubernetes.io/region"]; ok </span><span class="cov0" title="0">{
                ch.Region = val
                logger.Info("Detected", "IBM Cluster region: ", ch.Region)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Node label 'ibm-cloud.kubernetes.io/region' not found")
        }</span>

        <span class="cov0" title="0">logger.Info("Get IBM cluster IaaS Provider...")
        if val, ok := nodes.Items[0].Labels["ibm-cloud.kubernetes.io/iaas-provider"]; ok </span><span class="cov0" title="0">{
                logger.Info("Detected", "IBM IaaS provider: ", val)
                if val == "g2" </span><span class="cov0" title="0">{
                        ch.IaaSProvider = constants.IaasIBMVPC
                }</span> else<span class="cov0" title="0"> {
                        ch.IaaSProvider = constants.IaasIBMClassic
                }</span>
                <span class="cov0" title="0">logger.Info("Detected", "endpoint type: ", ch.IaaSProvider)</span>
        } else<span class="cov0" title="0"> {
                logger.Info("Node label 'ibm-cloud.kubernetes.io/iaas-provider' not found")
        }</span>

        <span class="cov0" title="0">if ch.Region == "" || ch.IaaSProvider == "" </span><span class="cov0" title="0">{
                // check if it is unmanaged cluster
                logger.Info("Region or IaaSProvider not set. checking if it is unmanaged cluster")

                ocClient, err := openshiftclient.NewForConfig(&amp;inConfig)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Unable to load cluster config")
                        return err
                }</span>

                <span class="cov0" title="0">infra, err := ocClient.ConfigV1().Infrastructures().Get(context.TODO(), "cluster", metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed to get infrastructure")
                        return err
                }</span>

                <span class="cov0" title="0">logger.Info("cluster infrastructure", "platformStatus:", infra.Status.PlatformStatus)

                platformType := infra.Status.PlatformStatus.Type
                logger.Info("Detected", "infra cloud provider platform: ", platformType)

                if platformType == constants.InfraProviderPlatformIBM </span><span class="cov0" title="0">{
                        logger.Info("Get cluster region...")
                        region := infra.Status.PlatformStatus.IBMCloud.Location
                        if region != "" </span><span class="cov0" title="0">{
                                ch.Region = region
                                logger.Info("Detected", "Cluster region: ", ch.Region)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info("cluster region not found")
                        }</span>

                        <span class="cov0" title="0">logger.Info("Get cluster Provider...")
                        providerType := infra.Status.PlatformStatus.IBMCloud.ProviderType
                        if providerType != "" </span><span class="cov0" title="0">{
                                logger.Info("Detected", "IaaS provider: ", providerType)
                                if providerType == constants.InfraProviderType </span><span class="cov0" title="0">{
                                        ch.IaaSProvider = constants.IaasIBMVPC
                                }</span> else<span class="cov0" title="0"> {
                                        ch.IaaSProvider = constants.IaasIBMClassic
                                }</span>
                                <span class="cov0" title="0">logger.Info("Detected", "endpoint type: ", ch.IaaSProvider)</span>
                        } else<span class="cov0" title="0"> {
                                logger.Info("cluster IaaS provider not found")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Info("cloud provider is not IBMCloud")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ch *ControllerHelper) GetS3Provider() string <span class="cov0" title="0">{
        return ch.S3Provider
}</span>

func (ch *ControllerHelper) GetIaaSProvider() string <span class="cov0" title="0">{
        return ch.IaaSProvider
}</span>

func (ch *ControllerHelper) GetRegion() string <span class="cov0" title="0">{
        return ch.Region
}</span>

func (ch *ControllerHelper) GetCosEP() string <span class="cov0" title="0">{
        return ch.CosEP
}</span>

func (ch *ControllerHelper) GetIBMCosSC() []string <span class="cov0" title="0">{
        if len(ch.IaaSProvider) == 0 || len(ch.Region) == 0 </span><span class="cov0" title="0">{
                return make([]string, 0)
        }</span>
        <span class="cov0" title="0">cosSC := []string{"standard", "smart"}
        return cosSC</span>
}

func (ch *ControllerHelper) SetIBMCosEP() <span class="cov0" title="0">{
        if len(ch.IaaSProvider) == 0 || len(ch.Region) == 0 </span><span class="cov0" title="0">{
                ch.CosEP = ""
        }</span>
        <span class="cov0" title="0">if ch.IaaSProvider == constants.IaasIBMVPC || ch.IaaSProvider == constants.IaasIBMClassic </span><span class="cov0" title="0">{
                epType := "private"
                if ch.IaaSProvider == constants.IaasIBMVPC </span><span class="cov0" title="0">{
                        epType = "direct"
                }</span>
                <span class="cov0" title="0">ch.CosEP = fmt.Sprintf(constants.IBMEP, epType, ch.Region)</span>
        }
}

func (ch *ControllerHelper) SetS3ProviderEP() <span class="cov0" title="0">{
        if ch.S3ProviderRegion == "" </span><span class="cov0" title="0">{
                ch.CosEP = ""
        }</span>

        <span class="cov0" title="0">if ch.S3Provider == constants.S3ProviderAWS </span><span class="cov0" title="0">{
                ch.CosEP = fmt.Sprintf(constants.AWSEP, ch.S3ProviderRegion)
        }</span>

        <span class="cov0" title="0">if ch.S3Provider == constants.S3ProviderWasabi </span><span class="cov0" title="0">{
                ch.CosEP = fmt.Sprintf(constants.WasabiEP, ch.S3ProviderRegion)
        }</span>
}

// Update finalizer to Controller Deployment under NS "ibm-object-csi-operator"
// op = 1  Add finalizer    op = 2  Remove finalizer
func (ch *ControllerHelper) updateControllerFinalizer(ctx context.Context, op constants.FinalizerOps, finalizerName string) error <span class="cov0" title="0">{
        logger := ch.Log.WithValues("name", constants.DeploymentName, "namespace", constants.CSIOperatorNamespace, "finalizer", finalizerName)
        logger.Info("updateControllerFinalizer: Entry")
        defer logger.Info("updateControllerFinalizer: Exit")

        ctrlDep := &amp;appsv1.Deployment{}
        err := ch.Get(ctx, client.ObjectKey{Namespace: constants.CSIOperatorNamespace, Name: constants.DeploymentName}, ctrlDep)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "updateControllerFinalizer: controller deployment not found. Retrying...")
                return err
        }</span>

        <span class="cov0" title="0">if op == constants.AddFinalizer </span><span class="cov0" title="0">{ // Add finalizer
                logger.Info("updateControllerFinalizer: adding finalizer to controller deployment")
                if exists := controllerutil.ContainsFinalizer(ctrlDep, finalizerName); !exists </span><span class="cov0" title="0">{
                        controllerutil.AddFinalizer(ctrlDep, finalizerName)
                        err = ch.Update(ctx, ctrlDep)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "updateControllerFinalizer: failed to add finalizer to controller deployment")
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Info("updateControllerFinalizer: finalizer has been added to controller deployment")</span>
                } else<span class="cov0" title="0"> {
                        logger.Info("updateControllerFinalizer: finalizer already present in controller deployment. Ignoring...")
                }</span>
        }

        <span class="cov0" title="0">if op == constants.RemoveFinalizer </span><span class="cov0" title="0">{ // Remove finalizer
                logger.Info("updateControllerFinalizer: removing finalizer from controller deployment")
                if exists := controllerutil.ContainsFinalizer(ctrlDep, finalizerName); exists </span><span class="cov0" title="0">{
                        controllerutil.RemoveFinalizer(ctrlDep, finalizerName)
                        err = ch.Update(ctx, ctrlDep)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "updateControllerFinalizer: failed to remove finalizer from controller deployment")
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Info("updateControllerFinalizer: finalizer has been removed from controller deployment")</span>
                } else<span class="cov0" title="0"> {
                        logger.Info("updateControllerFinalizer: finalizer not found in controller deployment. Ignoring...")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package util ...
package util

import "strings"

// Contains ...
func Contains(list []string, s string) bool <span class="cov0" title="0">{
        for _, v := range list </span><span class="cov0" title="0">{
                if v == s </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Remove ...
func Remove(list []string, s string) []string <span class="cov0" title="0">{
        newList := []string{}
        for _, v := range list </span><span class="cov0" title="0">{
                val := strings.TrimSpace(v)
                if val != s </span><span class="cov0" title="0">{
                        newList = append(newList, val)
                }</span>
        }
        <span class="cov0" title="0">return newList</span>
}

// MatchesPrefix ...
func MatchesPrefix(list []string, s string) bool <span class="cov0" title="0">{
        for _, v := range list </span><span class="cov0" title="0">{
                if strings.HasPrefix(s, v) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package main ...
package main

import (
        "flag"
        "os"
        "time"

        // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
        // to ensure that exec-entrypoint and run can make use of them.

        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        _ "k8s.io/client-go/plugin/pkg/client/auth"
        "k8s.io/client-go/rest"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/cache"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"

        objectdriverv1alpha1 "github.com/IBM/ibm-object-csi-driver-operator/api/v1alpha1"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/constants"
        "github.com/IBM/ibm-object-csi-driver-operator/controllers/util/common"
        //+kubebuilder:scaffold:imports
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov0" title="0">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))

        utilruntime.Must(objectdriverv1alpha1.AddToScheme(scheme))
        //+kubebuilder:scaffold:scheme
}</span>

func main() <span class="cov0" title="0">{
        var metricsAddr string
        var enableLeaderElection bool
        var probeAddr string
        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")

        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)
        flag.Parse()

        ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))

        mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme:                 scheme,
                Metrics:                metricsserver.Options{BindAddress: metricsAddr},
                HealthProbeBindAddress: probeAddr,
                LeaderElection:         enableLeaderElection,
                LeaderElectionID:       "af88e983.csi.ibm.com",
                Cache: cache.Options{
                        DefaultLabelSelector: labels.SelectorFromSet(constants.CommonCSIResourceLabelForCaching),
                },

                // LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
                // when the Manager ends. This requires the binary to immediately end when the
                // Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
                // speeds up voluntary leader transitions as the new leader don't have to wait
                // LeaseDuration time first.
                //
                // In the default scaffold provided, the program ends immediately after
                // the manager stops, so would be fine to enable this option. However,
                // if you are doing or is intended to do any operation such as perform cleanups
                // after the manager stops then its usage might be unsafe.
                // LeaderElectionReleaseOnCancel: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">controllerHelper := common.NewControllerHelper(mgr.GetClient(), setupLog)

        // TODO: TIER Based SC Get cluster info
        inConfig, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "GetClusterInfo: Unable to load config")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">for retry := 1; retry &lt;= 10; retry++ </span><span class="cov0" title="0">{
                time.Sleep(5 * time.Second)
                err = controllerHelper.GetClusterInfo(*inConfig)
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "GetClusterInfo: failed to get cluster details. Retry after 5 seconds...")
                }</span> else<span class="cov0" title="0"> {
                        setupLog.Info("GetClusterInfo: cluster details fetched successfully")
                        break</span>
                }
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "GetClusterInfo: failed to get cluster details after 10 attempts...")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;controllers.IBMObjectCSIReconciler{
                Client:           mgr.GetClient(),
                Scheme:           mgr.GetScheme(),
                ControllerHelper: controllerHelper,
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "IBMObjectCSI")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;controllers.RecoverStaleVolumeReconciler{
                Client: mgr.GetClient(),
                Scheme: mgr.GetScheme(),
                IsTest: false,
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "RecoverStaleVolume")
                os.Exit(1)
        }</span>
        //+kubebuilder:scaffold:builder

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
